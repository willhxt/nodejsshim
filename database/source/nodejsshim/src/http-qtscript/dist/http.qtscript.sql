--DO NOT EDIT THIS FILE! This file is generated by running the 'npm run build' command from this repos root. 
SELECT nodejsshim.npm_install('nodejsshim'::text, 'http'::text, '1.0.0-rc'::text, 'https://github.com/xtuple/qt-script-node-js-shims'::text, $code_body$ 
require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var util = require('util');
var IncomingMessage = require('./incoming-message.qtscript').ClientIncomingMessage;

/**
 * Emulate Node.js's `http.ClientRequest` class using Qt's QNetworkRequest class.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/http.html#http_class_http_clientrequest
 *
 * @param {Object} [options] - The socket connection options.
 */
function ClientRequest(options, cb) {
  var self = this;

  this.port = options.port || 80;
  this.scheme = (this.port === 80) ? "http://" : "https://";
  this.headers = {};
  this.hostname = options.hostname || options.host;
  this.path = options.path || "/";
  this.uri = this.scheme + this.hostname + this.path;

  this._timer = false;
  this._timeout = 60 * 1000;
  this._idleTime = Date.now() + this._timeout;

  this.QNetworkManager = new QNetworkAccessManager(mywindow);
  this.QNetworkRequest = new QNetworkRequest();

  // TODO: Implement other methods.
  function otherMethod () {
    throw new Error("HTTP Method not supported yet.");
  }
  function wrapDelete () {
    return self.QNetworkManager.deleteResource(self.QNetworkRequest);
  }
  function wrapGet (data) {
    if (data) {
      return self.QNetworkManager.sendCustomRequest(self.QNetworkRequest, QByteArray('GET'), new QBuffer(new QByteArray(data)));
    } else {
      return self.QNetworkManager.get(self.QNetworkRequest);
    }
  }
  function wrapHead () {
    return self.QNetworkManager.head(self.QNetworkRequest);
  }
  function wrapOptions (data) {
    return self.QNetworkManager.sendCustomRequest(self.QNetworkRequest, QByteArray('OPTIONS'), new QBuffer(new QByteArray(data)));
  }
  function wrapPatch (data) {
    return self.QNetworkManager.sendCustomRequest(self.QNetworkRequest, QByteArray('PATCH'), new QBuffer(new QByteArray(data)));
  }
  function wrapPost (data) {
    return self.QNetworkManager.post(self.QNetworkRequest, QByteArray(data));
  }
  function wrapPut (data) {
    return self.QNetworkManager.put(self.QNetworkRequest, QByteArray(data));
  }
  this.method = options.method || "GET";
  this.methodMap = {
    "DELETE": wrapDelete,
    "GET": wrapGet,
    "HEAD": wrapHead,
    "OPTIONS": wrapOptions,
    "PATCH": wrapPatch,
    "POST": wrapPost,
    "PUT": wrapPut
  };

  this.QNetworkRequest.setUrl(QUrl(this.uri));

  if (options.headers) {
    for (header in options.headers) {
      if (options.headers[header]) {
        self.QNetworkRequest.setRawHeader(QByteArray(header), QByteArray(options.headers[header]));
        self.headers[header] = options.headers[header];
      }
    }
  }

  if (options.ciphers) {
    // TODO: Support ciphers
    // @See: https://doc.qt.io/qt-5/qnetworkrequest.html#setSslConfiguration
  }

  if (cb) {
    this.callback = cb;
  }

  this.response = new IncomingMessage(this.methodMap[this.method], this.QNetworkRequest);

  this.response.once('response', function (res) {
    self.emit('response', res);
  });

  // QNetworkAccessManager doesn't open a socket and wait. So we have to
  // emit 'socket' from `ClientIncomingMessage` first and then 'connect'
  // or 'secureConnect'.
  this.response.once('socket', function (res) {
    self.emit('socket', res);
    res.emit((res.port === 80) ? 'connect' : 'secureConnect', res, res, res.headers);
  });

  return this;
}

util.inherits(ClientRequest, EventEmitter);

/**
 * Emulate Node.js's ClientRequest `request.abort()` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/http.html#http_request_abort
 */
ClientRequest.prototype.abort = function abort () {
  this.response.QNetworkReply.abort();
  this.emit('abort');
};

/**
 * Emulate Node.js's ClientRequest `request.end([data][, encoding][, callback])` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/http.html#http_request_end_data_encoding_callback
 */
ClientRequest.prototype.end = function end (data, encoding, callback) {
  var self = this;

  if (data) {
    this.response.data = data;
  }

  this.response.executeRequest();

  if (this.callback) {
    this.callback(this.response);
  }
};

/**
 * Emulate Node.js's ClientRequest `request.flushHeaders()` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/http.html#http_request_flushheaders
 */
ClientRequest.prototype.flushHeaders = function flushHeaders () {
  // TODO: QNetworkRequest doesn't have any way to support this. It's not required.
};

/**
 * Emulate Node.js's ClientRequest `request.setNoDelay([noDelay])` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/http.html#http_request_setnodelay_nodelay
 */
ClientRequest.prototype.setNoDelay = function setNoDelay (noDelay) {
  // TODO: QNetworkRequest doesn't have any way to support this. It's not required.
};

/**
 * Emulate Node.js's ClientRequest `request.setSocketKeepAlive([enable][, initialDelay])` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/http.html#http_request_setsocketkeepalive_enable_initialdelay
 */
ClientRequest.prototype.setSocketKeepAlive = function setSocketKeepAlive (noDelay) {
  // TODO: QNetworkRequest doesn't have any way to support this. It's not required.
};

/**
 * Emulate Node.js's ClientRequest `request.setTimeout(timeout[, callback])` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/http.html#http_request_settimeout_timeout_callback
 *
 * @param {Number} timeout - Sets the socket to timeout after timeout milliseconds
 *   of inactivity on the socket.
 * @param {Function} [callback] - The function to call when the idle timeout is reached.
 * @return {ClientRequest}
 */
ClientRequest.prototype.setTimeout = function setTimeout (timeout, callback) {
  var self = this;

  if (self._timer && timeout === 0) {
    clearInterval(self._timer);
  } else {
    if (callback) {
      self.once('timeout', callback);
    }
    self._timeout = timeout;
    self._idleTime = Date.now() + self._timeout;

    // Once a second, check if we hit the idle timeout.
    self._timer = setInterval(function () {
      if (self._idleTime < Date.now()) {
        self.emit('timeout');
      }
    }, 1000);
  }

  return this;
};

/**
 * Emulate Node.js's ClientRequest `request.write(chunk[, encoding][, callback])` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/http.html#http_request_write_chunk_encoding_callback
 */
ClientRequest.prototype.write = function write (chunk, encoding, callback) {
  var self = this;

  this.response.data = chunk;

  if (this.callback) {
    this.callback(this.response);
  }
};

module.exports = ClientRequest;

},{"./incoming-message.qtscript":3,"events":undefined,"util":undefined}],2:[function(require,module,exports){
var HTTPParser = require('http-parser-js').HTTPParser;

var IncomingMessage = require('./incoming-message.qtscript').ServerIncomingMessage;

// This is a free list to avoid creating so many of the same object.
function FreeList(name, max, constructor) {
  this.name = name;
  this.constructor = constructor;
  this.max = max;
  this.list = [];
};

FreeList.prototype.alloc = function() {
  return this.list.length ? this.list.pop() :
                            this.constructor.apply(this, arguments);
};

FreeList.prototype.free = function(obj) {
  if (this.list.length < this.max) {
    this.list.push(obj);
    return true;
  }
  return false;
};

exports.debug = function (message) {
  //console.log(message);
};

exports.CRLF = '\r\n';
exports.chunkExpression = /chunk/i;
exports.continueExpression = /100-continue/i;
exports.methods = HTTPParser.methods;

var kOnHeaders = HTTPParser.kOnHeaders | 0;
var kOnHeadersComplete = HTTPParser.kOnHeadersComplete | 0;
var kOnBody = HTTPParser.kOnBody | 0;
var kOnMessageComplete = HTTPParser.kOnMessageComplete | 0;
var kOnExecute = HTTPParser.kOnExecute | 0;

// Only called in the slow case where slow means
// that the request headers were either fragmented
// across multiple TCP packets or too large to be
// processed in a single run. This method is also
// called to process trailing HTTP headers.
function parserOnHeaders(headers, url) {
  // Once we exceeded headers limit - stop collecting them
  if (this.maxHeaderPairs <= 0 ||
      this._headers.length < this.maxHeaderPairs) {
    this._headers = this._headers.concat(headers);
  }
  this._url += url;
}

// `headers` and `url` are set only if .onHeaders() has not been called for
// this request.
// `url` is not set for response parsers but that's not applicable here since
// all our parsers are request parsers.
function parserOnHeadersComplete(versionMajor, versionMinor, headers, method,
                                 url, statusCode, statusMessage, upgrade,
                                 shouldKeepAlive) {
  var parser = this;

  if (!headers) {
    headers = parser._headers;
    parser._headers = [];
  }

  if (!url) {
    url = parser._url;
    parser._url = '';
  }

  parser.incoming = new IncomingMessage(parser.socket);
  parser.incoming.httpVersionMajor = versionMajor;
  parser.incoming.httpVersionMinor = versionMinor;
  parser.incoming.httpVersion = versionMajor + '.' + versionMinor;
  parser.incoming.url = url;

  var n = headers.length;

  // If parser.maxHeaderPairs <= 0 assume that there's no limit.
  if (parser.maxHeaderPairs > 0)
    n = Math.min(n, parser.maxHeaderPairs);

  parser.incoming._addHeaderLines(headers, n);

  if (typeof method === 'number') {
    // server only
    parser.incoming.method = HTTPParser.methods[method];
  } else {
    // client only
    parser.incoming.statusCode = statusCode;
    parser.incoming.statusMessage = statusMessage;
  }

  // The client made non-upgrade request, and server is just advertising
  // supported protocols.
  //
  // See RFC7230 Section 6.7
  //
  // NOTE: RegExp below matches `upgrade` in `Connection: abc, upgrade, def`
  // header.
  if (upgrade &&
      parser.outgoing !== null &&
      (parser.outgoing._headers.upgrade === undefined ||
       !/(^|\W)upgrade(\W|$)/i.test(parser.outgoing._headers.connection))) {
    upgrade = false;
  }

  parser.incoming.upgrade = upgrade;

  var skipBody = false; // response to HEAD or CONNECT

  if (!upgrade) {
    // For upgraded connections and CONNECT method request, we'll emit this
    // after parser.execute so that we can capture the first part of the new
    // protocol.
    skipBody = parser.onIncoming(parser.incoming, shouldKeepAlive);
  }

  return skipBody;
}

// XXX This is a mess.
// TODO: http.Parser should be a Writable emits request/response events.
function parserOnBody(b, start, len) {
  var parser = this;
  var stream = parser.incoming;

  // if the stream has already been removed, then drop it.
  if (!stream)
    return;

  var socket = stream.socket;

  // pretend this was the result of a stream._read call.
  if (len > 0 && !stream._dumped) {
    var slice = b.slice(start, start + len);
    var ret = stream.push(slice);
    if (!ret)
      readStop(socket);
  }
}

function parserOnMessageComplete() {
  var parser = this;
  var stream = parser.incoming;

  if (stream) {
    stream.complete = true;
    // Emit any trailing headers.
    var headers = parser._headers;
    if (headers) {
      parser.incoming._addHeaderLines(headers, headers.length);
      parser._headers = [];
      parser._url = '';
    }

    // Not needed for Qt
    // For emit end event
    //stream.push(null);
  }

  // Not needed for Qt
  // force to read the next incoming message
  //readStart(parser.socket);
}

var parsers = new FreeList('parsers', 1000, function() {
  var parser = new HTTPParser(HTTPParser.REQUEST);

  parser._headers = [];
  parser._url = '';
  parser._consumed = false;

  parser.socket = null;
  parser.incoming = null;
  parser.outgoing = null;

  // Only called in the slow case where slow means
  // that the request headers were either fragmented
  // across multiple TCP packets or too large to be
  // processed in a single run. This method is also
  // called to process trailing HTTP headers.
  parser[kOnHeaders] = parserOnHeaders;
  parser[kOnHeadersComplete] = parserOnHeadersComplete;
  parser[kOnBody] = parserOnBody;
  parser[kOnMessageComplete] = parserOnMessageComplete;
  parser[kOnExecute] = null;

  return parser;
});
exports.parsers = parsers;

// Free the parser and also break any links that it
// might have to any other things.
// TODO: All parser data should be attached to a
// single object, so that it can be easily cleaned
// up by doing `parser.data = {}`, which should
// be done in FreeList.free.  `parsers.free(parser)`
// should be all that is needed.
function freeParser(parser, req, socket) {
  if (parser) {
    parser._headers = [];
    parser.onIncoming = null;
    if (parser._consumed)
      parser.unconsume();
    parser._consumed = false;
    if (parser.socket)
      parser.socket.parser = null;
    parser.socket = null;
    parser.incoming = null;
    parser.outgoing = null;
    parser[kOnExecute] = null;
    if (parsers.free(parser) === false)
      parser.close();
    parser = null;
  }
  if (req) {
    req.parser = null;
  }
  if (socket) {
    socket.parser = null;
  }
}
exports.freeParser = freeParser;

function ondrain() {
  if (this._httpMessage) this._httpMessage.emit('drain');
}

function httpSocketSetup(socket) {
  socket.removeListener('drain', ondrain);
  socket.on('drain', ondrain);
}
exports.httpSocketSetup = httpSocketSetup;

/**
 * Verifies that the given val is a valid HTTP token
 * per the rules defined in RFC 7230
 **/
var token = /^[a-zA-Z0-9_!#$%&'*+.^`|~-]+$/;
function checkIsHttpToken(val) {
  return typeof val === 'string' && token.test(val);
}
exports._checkIsHttpToken = checkIsHttpToken;

/**
 * True if val contains an invalid field-vchar
 *  field-value    = *( field-content / obs-fold )
 *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 *  field-vchar    = VCHAR / obs-text
 **/
function checkInvalidHeaderChar(val) {
  val = '' + val;
  for (var i = 0; i < val.length; i++) {
    var ch = val.charCodeAt(i);
    if (ch === 9) continue;
    if (ch <= 31 || ch > 255 || ch === 127) return true;
  }
  return false;
}
exports._checkInvalidHeaderChar = checkInvalidHeaderChar;

},{"./incoming-message.qtscript":3,"http-parser-js":8}],3:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var util = require('util');

var utils = require('./utils.qtscript');

/**
 * Emulate Node.js's `http.IncomingMessage` class using Qt's QNetworkReply class.
 * This is used by http.ClientRequest.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/http.html#http_class_http_incomingmessage
 *
 * @param {Object} [options] - The socket connection options.
 */
function ClientIncomingMessage(requestHandler, qNetworkRequest) {
  this.QNetworkRequest = qNetworkRequest;
  var self = this;

  this.complete = false;
  this.hasData = false;
  this.isReading = false;
  this._encoding = 'utf8';
  this.readable = true;
  this.httpVersionMajor = null;
  this.httpVersionMinor = null;
  this._timer = false;
  this._timeout = 60 * 1000;
  this._idleTime = Date.now() + this._timeout;

  this.port = this.QNetworkRequest.url().port();
  this.data = null;
  this.headers = {};
  this.httpVersion = null;
  this.rawHeaders = [];
  this.rawTrailers = [];
  this.statusCode = null;
  this.statusMessage = null;
  this.trailers = {};

  this._requestHandler = function (data) {
    self.QNetworkReply = requestHandler(data);

    self.QNetworkReply["error(QNetworkReply::NetworkError)"].connect(_isError);
    self.QNetworkReply["metaDataChanged()"].connect(_isMetaDataChanged);
    self.QNetworkReply["downloadProgress(qint64, qint64)"].connect(_isDownloading);
    self.QNetworkReply["readyRead()"].connect(_isReadyRead);
    self.QNetworkReply["bytesWritten(qint64)"].connect(_isBytesWritten);
    self.QNetworkReply["finished()"].connect(_isFinished);
  };

  function _isDownloading (bytesReceived, bytesTotal) {
    if (bytesTotal !== 0) {
      self.hasData = true;
    }
  }

  function _isFinished () {
    self.readable = false;
    self.complete = true;

    // Sometimes `QNetworkReply` emits `finished()` before `readyRead()`, so we
    // use a setInterval loop to only emit `close` and `end` when we're really done.
    var timer = setInterval(function () {
      if (!self.hasData && !self.isReading) {
        clearInterval(timer);
        self.emit('close');
        self.emit('end');
      }
    }, 5);
  }
  function _isError (code) {
    if (code === 0) {
      return;
    }
    self._idleTime = Date.now() + self._timeout;
    self.QtQAbstractSocketSocketError = code;
  }
  function _readData () {
    var size = self.QNetworkReply.bytesAvailable();
    if (size > 0) {
      self.isReading = true;
      self._idleTime = Date.now() + self._timeout;

      var qba = self.QNetworkReply.readAll();
      var data = utils._convertQByteArrayToEncoding(qba, self._encoding);
      self.emit('data', data);
      setTimeout(function () { _readData(size);}, 0);
    } else {
      self.isReading = false;
      self.hasData = false;
    }
  }
  function _isReadyRead () {
    if (!self.isReading) {
      self.emit('response', self);
      setTimeout(_readData, 0);
    }
  }
  function _isMetaDataChanged () {
    self.headers = self.QNetworkReply.rawHeaderList().reduce(
                     function (previousValue, currentValue) {
                       if (self.QNetworkReply.hasRawHeader(QByteArray(currentValue))) {
                         previousValue[currentValue] = self.QNetworkReply.rawHeader(QByteArray(currentValue)).toString();
                       }
                       return previousValue;
                     },
                     {} // Initial value.
                   );
    self.statusCode = self.QNetworkReply.attribute(QNetworkRequest.HttpStatusCodeAttribute);
    self.statusMessage = self.QNetworkReply.attribute(QNetworkRequest.HttpReasonPhraseAttribute);
  }
  function _isBytesWritten(bytes) {
    self._idleTime = Date.now() + self._timeout;
    self.bytesWritten = bytes;
    self.emit('drain');
  }

  // QNetworkAccessManager doesn't open a socket and wait. So we have to
  // emit 'socket' first and then 'connect' or 'secureConnect' from
  // `ClientRequest` after a small delay.
  setTimeout(function () {
    self.emit('socket', self);
  }, 5);

  return this;
}

util.inherits(ClientIncomingMessage, EventEmitter);

/**
 * Execute the pending request.
 */
ClientIncomingMessage.prototype.executeRequest = function executeRequest () {
  this._requestHandler(this.data);
};

/**
 * Emulate Node.js's IncomingMessage `message.setEncoding(encoding)` method.
 */
ClientIncomingMessage.prototype.setEncoding = function setEncoding (encoding) {
  this._encoding = encoding;
};

/**
 * Emulate Node.js's IncomingMessage `message.setTimeout(msecs, callback)` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/http.html#http_message_settimeout_msecs_callback
 *
 * @param {Number} msecs - Sets the socket to timeout after timeout milliseconds
 *   of inactivity on the socket.
 * @param {Function} [callback] - The function to call when the idle timeout is reached.
 * @return {IncomingMessage}
 */
ClientIncomingMessage.prototype.setTimeout = function setTimeout (msecs, callback) {
  var self = this;

  if (self._timer && msecs === 0) {
    clearInterval(self._timer);
  } else {
    if (callback) {
      self.once('timeout', callback);
    }
    self._timeout = msecs;
    self._idleTime = Date.now() + self._timeout;

    // Once a second, check if we hit the idle timeout.
    self._timer = setInterval(function () {
      if (self._idleTime < Date.now()) {
        self.emit('timeout');
      }
    }, 1000);
  }

  return this;
};

function readStart(socket) {
  if (socket && !socket._paused && socket.readable)
    socket.resume();
}

/**
 * Emulate Node.js's `http.IncomingMessage` class using Qt's QTcpSocket class.
 * This is used by http.Server.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/http.html#http_class_http_incomingmessage
 *
 * @param {Object} [options] - The socket connection options.
 */
function ServerIncomingMessage(socket) {
  var self = this;

  this.complete = false;
  this.connection = socket;
  this.headers = {};
  this.httpVersion = null;
  this.httpVersionMajor = null;
  this.httpVersionMinor = null;
  this.method = null;
  this.rawHeaders = [];
  this.rawTrailers = [];
  this.readable = true;
  this.socket = socket;
  this.trailers = {};
  this.upgrade = null;
  this.url = '';

  // flag for when we decide that this message cannot possibly be
  // read by the user, so there's no point continuing to handle it.
  this._dumped = false;

  return this;
}

util.inherits(ServerIncomingMessage, EventEmitter);

/**
 * Emulate Node.js's IncomingMessage `message.setTimeout(msecs, callback)` method.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/http.html#http_message_settimeout_msecs_callback
 *
 * @param {Number} msecs - Sets the socket to timeout after timeout milliseconds
 *   of inactivity on the socket.
 * @param {Function} [callback] - The function to call when the idle timeout is reached.
 * @return {ServerIncomingMessage}
 */
ServerIncomingMessage.prototype.setTimeout = function setTimeout (msecs, callback) {
  if (callback) {
    this.on('timeout', callback);
  }
  this.socket.setTimeout(msecs);
  return this;
};

ServerIncomingMessage.prototype.read = function(n) {
  // TODO: Don't use Stream
  //this._consuming = true;
  //this.read = Stream.Readable.prototype.read;
  //return this.read(n);
  console.warn("ServerIncomingMessage.prototype.read() called, but it is not implemented in Qt Script yet.");
  return;
};

ServerIncomingMessage.prototype._read = function(n) {
  // We actually do almost nothing here, because the parserOnBody
  // function fills up our internal buffer directly.  However, we
  // do need to unpause the underlying socket so that it flows.
  if (this.socket.readable)
    readStart(this.socket);
};

// It's possible that the socket will be destroyed, and removed from
// any messages, before ever calling this.  In that case, just skip
// it, since something else is destroying this connection anyway.
ServerIncomingMessage.prototype.destroy = function(error) {
  if (this.socket)
    this.socket.destroy(error);
};

ServerIncomingMessage.prototype._addHeaderLines = function(headers, n) {
  if (headers && headers.length) {
    var raw, dest;
    if (this.complete) {
      raw = this.rawTrailers;
      dest = this.trailers;
    } else {
      raw = this.rawHeaders;
      dest = this.headers;
    }

    for (var i = 0; i < n; i += 2) {
      var k = headers[i];
      var v = headers[i + 1];
      raw.push(k);
      raw.push(v);
      this._addHeaderLine(k, v, dest);
    }
  }
};

// Add the given (field, value) pair to the message
//
// Per RFC2616, section 4.2 it is acceptable to join multiple instances of the
// same header with a ', ' if the header in question supports specification of
// multiple values this way. If not, we declare the first instance the winner
// and drop the second. Extended header fields (those beginning with 'x-') are
// always joined.
ServerIncomingMessage.prototype._addHeaderLine = function(field, value, dest) {
  field = field.toLowerCase();
  switch (field) {
    // Array headers:
    case 'set-cookie':
      if (dest[field] !== undefined) {
        dest[field].push(value);
      } else {
        dest[field] = [value];
      }
      break;

    /* eslint-disable max-len */
    // list is taken from:
    // https://mxr.mozilla.org/mozilla/source/netwerk/protocol/http/src/nsHttpHeaderArray.cpp
    /* eslint-enable max-len */
    case 'content-type':
    case 'content-length':
    case 'user-agent':
    case 'referer':
    case 'host':
    case 'authorization':
    case 'proxy-authorization':
    case 'if-modified-since':
    case 'if-unmodified-since':
    case 'from':
    case 'location':
    case 'max-forwards':
      // drop duplicates
      if (dest[field] === undefined)
        dest[field] = value;
      break;

    default:
      // make comma-separated list
      if (typeof dest[field] === 'string') {
        dest[field] += ', ' + value;
      } else {
        dest[field] = value;
      }
  }
};

// Call this instead of resume() if we want to just
// dump all the data to /dev/null
ServerIncomingMessage.prototype._dump = function() {
  if (!this._dumped) {
    this._dumped = true;
    this.resume();
  }
};

module.exports = {
  ClientIncomingMessage: ClientIncomingMessage,
  ServerIncomingMessage: ServerIncomingMessage
};

},{"./utils.qtscript":7,"events":undefined,"util":undefined}],4:[function(require,module,exports){
var assert = require('assert').ok;
var EventEmitter = require('events').EventEmitter;
var util = require('util');

var common = require('./common');

var CRLF = common.CRLF;
var chunkExpression = common.chunkExpression;
var debug = common.debug;

var connectionExpression = /^Connection$/i;
var transferEncodingExpression = /^Transfer-Encoding$/i;
var closeExpression = /close/i;
var contentLengthExpression = /^Content-Length$/i;
var dateExpression = /^Date$/i;
var expectExpression = /^Expect$/i;
var trailerExpression = /^Trailer$/i;

var automaticHeaders = {
  connection: true,
  'content-length': true,
  'transfer-encoding': true,
  date: true
};

var dateCache;
function utcDate() {
  if (!dateCache) {
    var d = new Date();
    dateCache = d.toUTCString();
    //timers.enroll(utcDate, 1000 - d.getMilliseconds());
    //timers._unrefActive(utcDate);
  }
  return dateCache;
}

/**
 * Emulate Node.js's `http.OutgoingMessage` class.
 */
function OutgoingMessage() {
  var self = this;

  // Queue that holds all currently pending data, until the response will be
  // assigned to the socket (until it will its turn in the HTTP pipeline).
  this.output = [];
  this.outputEncodings = [];
  this.outputCallbacks = [];

  // `outputSize` is an approximate measure of how much data is queued on this
  // response. `_onPendingData` will be invoked to update similar global
  // per-connection counter. That counter will be used to pause/unpause the
  // TCP socket and HTTP Parser and thus handle the backpressure.
  this.outputSize = 0;

  this.writable = true;

  this._last = false;
  this.chunkedEncoding = false;
  this.shouldKeepAlive = true;
  this.useChunkedEncodingByDefault = true;
  this.sendDate = false;
  this._removedHeader = {};

  this._contentLength = null;
  this._hasBody = true;
  this._trailer = '';

  this.finished = false;
  this._headerSent = false;

  this.socket = null;
  this.connection = null;
  this._header = null;
  this._headers = null;
  this._headerNames = {};

  this._onPendingData = null;

  return this;
}

util.inherits(OutgoingMessage, EventEmitter);

OutgoingMessage.prototype.setTimeout = function(msecs, callback) {

  if (callback) {
    this.on('timeout', callback);
  }

  if (!this.socket) {
    this.once('socket', function(socket) {
      socket.setTimeout(msecs);
    });
  } else {
    this.socket.setTimeout(msecs);
  }
  return this;
};

// It's possible that the socket will be destroyed, and removed from
// any messages, before ever calling this.  In that case, just skip
// it, since something else is destroying this connection anyway.
OutgoingMessage.prototype.destroy = function(error) {
  if (this.socket)
    this.socket.destroy(error);
  else
    this.once('socket', function(socket) {
      socket.destroy(error);
    });
};

// This abstract either writing directly to the socket or buffering it.
OutgoingMessage.prototype._send = function(data, encoding, callback) {
  // This is a shameful hack to get the headers and first body chunk onto
  // the same packet. Future versions of Node are going to take care of
  // this at a lower level and in a more general way.
  if (!this._headerSent) {
    if (typeof data === 'string' &&
        encoding !== 'hex' &&
        encoding !== 'base64') {
      data = this._header + data;
    } else {
      this.output.unshift(this._header);
      this.outputEncodings.unshift('binary');
      this.outputCallbacks.unshift(null);
      this.outputSize += this._header.length;
      if (typeof this._onPendingData === 'function')
        this._onPendingData(this._header.length);
    }
    this._headerSent = true;
  }
  return this._writeRaw(data, encoding, callback);
};

OutgoingMessage.prototype._writeRaw = function(data, encoding, callback) {
  if (typeof encoding === 'function') {
    callback = encoding;
    encoding = null;
  }

  var connection = this.connection;
  if (connection &&
      connection._httpMessage === this &&
      connection.writable &&
      !connection.destroyed) {
    // There might be pending data in the this.output buffer.
    var outputLength = this.output.length;
    if (outputLength > 0) {
      this._flushOutput(connection);
    } else if (data.length === 0) {
      if (typeof callback === 'function')
        process.nextTick(callback);
      return true;
    }

    // Directly write to socket.
    return connection.write(data, encoding, callback);
  } else if (connection && connection.destroyed) {
    // The socket was destroyed.  If we're still trying to write to it,
    // then we haven't gotten the 'close' event yet.
    return false;
  } else {
    // buffer, as long as we're not destroyed.
    return this._buffer(data, encoding, callback);
  }
};

OutgoingMessage.prototype._buffer = function(data, encoding, callback) {
  this.output.push(data);
  this.outputEncodings.push(encoding);
  this.outputCallbacks.push(callback);
  this.outputSize += data.length;
  if (typeof this._onPendingData === 'function')
    this._onPendingData(data.length);
  return false;
};

OutgoingMessage.prototype._storeHeader = function(firstLine, headers) {
  // firstLine in the case of request is: 'GET /index.html HTTP/1.1\r\n'
  // in the case of response it is: 'HTTP/1.1 200 OK\r\n'
  var state = {
    sentConnectionHeader: false,
    sentContentLengthHeader: false,
    sentTransferEncodingHeader: false,
    sentDateHeader: false,
    sentExpect: false,
    sentTrailer: false,
    messageHeader: firstLine
  };

  if (headers) {
    var keys = Object.keys(headers);
    var isArray = Array.isArray(headers);
    var field, value;

    for (var i = 0, l = keys.length; i < l; i++) {
      var key = keys[i];
      if (isArray) {
        field = headers[key][0];
        value = headers[key][1];
      } else {
        field = key;
        value = headers[key];
      }

      if (Array.isArray(value)) {
        for (var j = 0; j < value.length; j++) {
          storeHeader(this, state, field, value[j]);
        }
      } else {
        storeHeader(this, state, field, value);
      }
    }
  }

  // Date header
  if (this.sendDate === true && state.sentDateHeader === false) {
    state.messageHeader += 'Date: ' + utcDate() + CRLF;
  }

  // Force the connection to close when the response is a 204 No Content or
  // a 304 Not Modified and the user has set a "Transfer-Encoding: chunked"
  // header.
  //
  // RFC 2616 mandates that 204 and 304 responses MUST NOT have a body but
  // node.js used to send out a zero chunk anyway to accommodate clients
  // that don't have special handling for those responses.
  //
  // It was pointed out that this might confuse reverse proxies to the point
  // of creating security liabilities, so suppress the zero chunk and force
  // the connection to close.
  var statusCode = this.statusCode;
  if ((statusCode === 204 || statusCode === 304) &&
      this.chunkedEncoding === true) {
    debug(statusCode + ' response should not use chunked encoding,' +
          ' closing connection.');
    this.chunkedEncoding = false;
    this.shouldKeepAlive = false;
  }

  // keep-alive logic
  if (this._removedHeader.connection) {
    this._last = true;
    this.shouldKeepAlive = false;
  } else if (state.sentConnectionHeader === false) {
    var shouldSendKeepAlive = this.shouldKeepAlive &&
        (state.sentContentLengthHeader ||
         this.useChunkedEncodingByDefault ||
         this.agent);
    if (shouldSendKeepAlive) {
      state.messageHeader += 'Connection: keep-alive\r\n';
    } else {
      this._last = true;
      state.messageHeader += 'Connection: close\r\n';
    }
  }

  if (state.sentContentLengthHeader === false &&
      state.sentTransferEncodingHeader === false) {
    if (!this._hasBody) {
      // Make sure we don't end the 0\r\n\r\n at the end of the message.
      this.chunkedEncoding = false;
    } else if (!this.useChunkedEncodingByDefault) {
      this._last = true;
    } else {
      if (!state.sentTrailer &&
          !this._removedHeader['content-length'] &&
          typeof this._contentLength === 'number') {
        state.messageHeader += 'Content-Length: ' + this._contentLength +
                               '\r\n';
      } else if (!this._removedHeader['transfer-encoding']) {
        state.messageHeader += 'Transfer-Encoding: chunked\r\n';
        this.chunkedEncoding = true;
      } else {
        // We should only be able to get here if both Content-Length and
        // Transfer-Encoding are removed by the user.
        // See: test/parallel/test-http-remove-header-stays-removed.js
        debug('Both Content-Length and Transfer-Encoding are removed');
      }
    }
  }

  this._header = state.messageHeader + CRLF;
  this._headerSent = false;

  // wait until the first body chunk, or close(), is sent to flush,
  // UNLESS we're sending Expect: 100-continue.
  if (state.sentExpect) this._send('');
};

function storeHeader(self, state, field, value) {
  if (!common._checkIsHttpToken(field)) {
    throw new TypeError(
      'Header name must be a valid HTTP Token ["' + field + '"]');
  }
  if (common._checkInvalidHeaderChar(value) === true) {
    throw new TypeError('The header content contains invalid characters');
  }
  state.messageHeader += field + ': ' + escapeHeaderValue(value) + CRLF;

  if (connectionExpression.test(field)) {
    state.sentConnectionHeader = true;
    if (closeExpression.test(value)) {
      self._last = true;
    } else {
      self.shouldKeepAlive = true;
    }

  } else if (transferEncodingExpression.test(field)) {
    state.sentTransferEncodingHeader = true;
    if (chunkExpression.test(value)) self.chunkedEncoding = true;

  } else if (contentLengthExpression.test(field)) {
    state.sentContentLengthHeader = true;
  } else if (dateExpression.test(field)) {
    state.sentDateHeader = true;
  } else if (expectExpression.test(field)) {
    state.sentExpect = true;
  } else if (trailerExpression.test(field)) {
    state.sentTrailer = true;
  }
}

OutgoingMessage.prototype.setHeader = function(name, value) {
  if (!common._checkIsHttpToken(name))
    throw new TypeError(
      'Header name must be a valid HTTP Token ["' + name + '"]');
  if (typeof name !== 'string')
    throw new TypeError('"name" should be a string in setHeader(name, value)');
  if (value === undefined)
    throw new Error('"value" required in setHeader("' + name + '", value)');
  if (this._header)
    throw new Error('Can\'t set headers after they are sent.');
  if (common._checkInvalidHeaderChar(value) === true) {
    throw new TypeError('The header content contains invalid characters');
  }
  if (this._headers === null)
    this._headers = {};

  var key = name.toLowerCase();
  this._headers[key] = value;
  this._headerNames[key] = name;

  if (automaticHeaders[key])
    this._removedHeader[key] = false;
};

OutgoingMessage.prototype.getHeader = function(name) {
  if (arguments.length < 1) {
    throw new Error('"name" argument is required for getHeader(name)');
  }

  if (!this._headers) return;

  var key = name.toLowerCase();
  return this._headers[key];
};

OutgoingMessage.prototype.removeHeader = function(name) {
  if (arguments.length < 1) {
    throw new Error('"name" argument is required for removeHeader(name)');
  }

  if (this._header) {
    throw new Error('Can\'t remove headers after they are sent');
  }

  var key = name.toLowerCase();

  if (key === 'date')
    this.sendDate = false;
  else if (automaticHeaders[key])
    this._removedHeader[key] = true;

  if (this._headers) {
    delete this._headers[key];
    delete this._headerNames[key];
  }
};

OutgoingMessage.prototype._renderHeaders = function() {
  if (this._header) {
    throw new Error('Can\'t render headers after they are sent to the client');
  }

  var headersMap = this._headers;
  if (!headersMap) return {};

  var headers = {};
  var keys = Object.keys(headersMap);
  var headerNames = this._headerNames;

  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    headers[headerNames[key]] = headersMap[key];
  }
  return headers;
};

Object.defineProperty(OutgoingMessage.prototype, 'headersSent', {
  configurable: true,
  enumerable: true,
  get: function() { return !!this._header; }
});

OutgoingMessage.prototype.write = function(chunk, encoding, callback) {
  if (this.finished) {
    var err = new Error('write after end');
    process.nextTick(writeAfterEndNT, this, err, callback);

    return true;
  }

  if (!this._header) {
    this._implicitHeader();
  }

  if (!this._hasBody) {
    debug('This type of response MUST NOT have a body. ' +
          'Ignoring write() calls.');
    return true;
  }

  if (typeof chunk !== 'string' && !(chunk instanceof Buffer)) {
    throw new TypeError('First argument must be a string or Buffer');
  }


  // If we get an empty string or buffer, then just do nothing, and
  // signal the user to keep writing.
  if (chunk.length === 0) return true;

  var len, ret;
  if (this.chunkedEncoding) {
    if (typeof chunk === 'string' &&
        encoding !== 'hex' &&
        encoding !== 'base64' &&
        encoding !== 'binary') {
      len = Buffer.byteLength(chunk, encoding);
      chunk = len.toString(16) + CRLF + chunk + CRLF;
      ret = this._send(chunk, encoding, callback);
    } else {
      // buffer, or a non-toString-friendly encoding
      if (typeof chunk === 'string')
        len = Buffer.byteLength(chunk, encoding);
      else
        len = chunk.length;

      // Not needed in Qt.
      //if (this.connection && !this.connection.corked) {
      //  this.connection.cork();
      //  process.nextTick(connectionCorkNT, this.connection);
      //}
      this._send(len.toString(16), 'binary', null);
      this._send(crlf_buf, null, null);
      this._send(chunk, encoding, null);
      ret = this._send(crlf_buf, null, callback);
    }
  } else {
    ret = this._send(chunk, encoding, callback);
  }

  debug('write ret = ' + ret);
  return ret;
};

function writeAfterEndNT(self, err, callback) {
  self.emit('error', err);
  if (callback) callback(err);
}

function connectionCorkNT(conn) {
  // Not needed in Qt
  //conn.uncork();
}

function escapeHeaderValue(value) {
  // Protect against response splitting. The regex test is there to
  // minimize the performance impact in the common case.
  return /[\r\n]/.test(value) ? value.replace(/[\r\n]+[ \t]*/g, '') : value;
}

OutgoingMessage.prototype.addTrailers = function(headers) {
  this._trailer = '';
  var keys = Object.keys(headers);
  var isArray = Array.isArray(headers);
  var field, value;
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    if (isArray) {
      field = headers[key][0];
      value = headers[key][1];
    } else {
      field = key;
      value = headers[key];
    }
    if (!common._checkIsHttpToken(field)) {
      throw new TypeError(
        'Trailer name must be a valid HTTP Token ["' + field + '"]');
    }
    if (common._checkInvalidHeaderChar(value) === true) {
      throw new TypeError('The trailer content contains invalid characters');
    }
    this._trailer += field + ': ' + escapeHeaderValue(value) + CRLF;
  }
};

var crlf_buf = new Buffer('\r\n');

OutgoingMessage.prototype.end = function(data, encoding, callback) {
  if (typeof data === 'function') {
    callback = data;
    data = null;
  } else if (typeof encoding === 'function') {
    callback = encoding;
    encoding = null;
  }

  if (data && typeof data !== 'string' && !(data instanceof Buffer)) {
    throw new TypeError('First argument must be a string or Buffer');
  }

  if (this.finished) {
    return false;
  }

  var self = this;
  function finish() {
    self.emit('finish');
    self.socket.QTcpSocket.disconnectFromHost();
  }

  if (typeof callback === 'function')
    this.once('finish', callback);

  if (!this._header) {
    if (data) {
      if (typeof data === 'string')
        this._contentLength = Buffer.byteLength(data, encoding);
      else
        this._contentLength = data.length;
    } else {
      this._contentLength = 0;
    }
    this._implicitHeader();
  }

  if (data && !this._hasBody) {
    debug('This type of response MUST NOT have a body. ' +
          'Ignoring data passed to end().');
    data = null;
  }

  // Not needed in Qt.
  //if (this.connection && data)
  //  this.connection.cork();

  var ret;
  if (data) {
    // Normal body write.
    this.write(data, encoding);
  }

  if (this._hasBody && this.chunkedEncoding) {
    ret = this._send('0\r\n' + this._trailer + '\r\n', 'binary', finish);
  } else {
    // Force a flush, HACK.
    ret = this._send('', 'binary', finish);
  }

  // Not needed in Qt
  //if (this.connection && data)
  //  this.connection.uncork();

  this.finished = true;

  // There is the first message on the outgoing queue, and we've sent
  // everything to the socket.
  debug('outgoing message end.');
  if (this.output.length === 0 &&
      this.connection &&
      this.connection._httpMessage === this) {
    this._finish();
  }

  return ret;
};

OutgoingMessage.prototype._finish = function() {
  assert(this.connection);
  this.emit('prefinish');
};

// This logic is probably a bit confusing. Let me explain a bit:
//
// In both HTTP servers and clients it is possible to queue up several
// outgoing messages. This is easiest to imagine in the case of a client.
// Take the following situation:
//
//    req1 = client.request('GET', '/');
//    req2 = client.request('POST', '/');
//
// When the user does
//
//   req2.write('hello world\n');
//
// it's possible that the first request has not been completely flushed to
// the socket yet. Thus the outgoing messages need to be prepared to queue
// up data internally before sending it on further to the socket's queue.
//
// This function, outgoingFlush(), is called by both the Server and Client
// to attempt to flush any pending messages out to the socket.
OutgoingMessage.prototype._flush = function() {
  var socket = this.socket;
  var ret;

  if (socket && socket.writable) {
    // There might be remaining data in this.output; write it out
    ret = this._flushOutput(socket);

    if (this.finished) {
      // This is a queue to the server or client to bring in the next this.
      this._finish();
    } else if (ret) {
      // This is necessary to prevent https from breaking
      this.emit('drain');
    }
  }
};

OutgoingMessage.prototype._flushOutput = function _flushOutput(socket) {
  var ret;
  var outputLength = this.output.length;
  if (outputLength <= 0)
    return ret;

  var output = this.output;
  var outputEncodings = this.outputEncodings;
  var outputCallbacks = this.outputCallbacks;
  socket.cork();
  for (var i = 0; i < outputLength; i++) {
    ret = socket.write(output[i], outputEncodings[i],
                       outputCallbacks[i]);
  }
  // Not needed in Qt
  //socket.uncork();

  this.output = [];
  this.outputEncodings = [];
  this.outputCallbacks = [];
  if (typeof this._onPendingData === 'function')
    this._onPendingData(-this.outputSize);
  this.outputSize = 0;

  return ret;
};

OutgoingMessage.prototype.flushHeaders = function() {
  if (!this._header) {
    this._implicitHeader();
  }

  // Force-flush the headers.
  this._send('');
};

module.exports = OutgoingMessage;

},{"./common":2,"assert":undefined,"events":undefined,"util":undefined}],5:[function(require,module,exports){
var assert = require('assert').ok;
var util = require('util');

var utils = require('./utils.qtscript');
var OutgoingMessage = require('./outgoing-message.qtscript');
var STATUS_CODES = utils.STATUS_CODES;

var CRLF = '\r\n';

/**
 * Emulate Node.js's `http.ServerResponse` class.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/http.html#http_class_http_serverresponse
 */
function ServerResponse(req) {
  var self = this;
  OutgoingMessage.call(this);

  if (req.method === 'HEAD') this._hasBody = false;

  this.sendDate = true;

  if (req.httpVersionMajor < 1 || req.httpVersionMinor < 1) {
    this.useChunkedEncodingByDefault = chunkExpression.test(req.headers.te);
    this.shouldKeepAlive = false;
  }

  return this;
}

util.inherits(ServerResponse, OutgoingMessage);

ServerResponse.prototype.statusCode = 200;
ServerResponse.prototype.statusMessage = undefined;

function onServerResponseClose() {
  // EventEmitter.emit makes a copy of the 'close' listeners array before
  // calling the listeners. detachSocket() unregisters onServerResponseClose
  // but if detachSocket() is called, directly or indirectly, by a 'close'
  // listener, onServerResponseClose is still in that copy of the listeners
  // array. That is, in the example below, b still gets called even though
  // it's been removed by a:
  //
  //   var EventEmitter = require('events');
  //   var obj = new EventEmitter();
  //   obj.on('event', a);
  //   obj.on('event', b);
  //   function a() { obj.removeListener('event', b) }
  //   function b() { throw "BAM!" }
  //   obj.emit('event');  // throws
  //
  // Ergo, we need to deal with stale 'close' events and handle the case
  // where the ServerResponse object has already been deconstructed.
  // Fortunately, that requires only a single if check. :-)
  if (this._httpMessage) this._httpMessage.emit('close');
}

ServerResponse.prototype.assignSocket = function(socket) {
  assert(!socket._httpMessage);
  socket._httpMessage = this;
  socket.on('close', onServerResponseClose);
  this.socket = socket;
  this.connection = socket;
  this.emit('socket', socket);
  //this._flush();
};

ServerResponse.prototype.detachSocket = function(socket) {
  assert(socket._httpMessage === this);
  socket.removeListener('close', onServerResponseClose);
  socket._httpMessage = null;
  this.socket = this.connection = null;
};

ServerResponse.prototype.writeContinue = function(cb) {
  this.socket.write('HTTP/1.1 100 Continue' + CRLF + CRLF, 'ascii', cb);
  //this._writeRaw('HTTP/1.1 100 Continue' + CRLF + CRLF, 'ascii', cb);
  this._sent100 = true;
};

ServerResponse.prototype._implicitHeader = function() {
  this.writeHead(this.statusCode);
};

ServerResponse.prototype.writeHead = function(statusCode, reason, obj) {
  var headers;

  if (typeof reason === 'string') {
    // writeHead(statusCode, reasonPhrase[, headers])
    this.statusMessage = reason;
  } else {
    // writeHead(statusCode[, headers])
    this.statusMessage =
        this.statusMessage || STATUS_CODES[statusCode] || 'unknown';
    obj = reason;
  }
  this.statusCode = statusCode;

  if (this._headers) {
    // Slow-case: when progressive API and header fields are passed.
    if (obj) {
      var keys = Object.keys(obj);
      for (var i = 0; i < keys.length; i++) {
        var k = keys[i];
        if (k) this.setHeader(k, obj[k]);
      }
    }
    // only progressive api is used
    headers = this._renderHeaders();
  } else {
    // only writeHead() called
    headers = obj;
  }

  var statusLine = 'HTTP/1.1 ' + statusCode.toString() + ' ' +
                   this.statusMessage + CRLF;

  if (statusCode === 204 || statusCode === 304 ||
      (100 <= statusCode && statusCode <= 199)) {
    // RFC 2616, 10.2.5:
    // The 204 response MUST NOT include a message-body, and thus is always
    // terminated by the first empty line after the header fields.
    // RFC 2616, 10.3.5:
    // The 304 response MUST NOT contain a message-body, and thus is always
    // terminated by the first empty line after the header fields.
    // RFC 2616, 10.1 Informational 1xx:
    // This class of status code indicates a provisional response,
    // consisting only of the Status-Line and optional headers, and is
    // terminated by an empty line.
    this._hasBody = false;
  }

  // don't keep alive connections where the client expects 100 Continue
  // but we sent a final status; they may put extra bytes on the wire.
  if (this._expect_continue && !this._sent100) {
    this.shouldKeepAlive = false;
  }

  this._storeHeader(statusLine, headers);
};

ServerResponse.prototype.writeHeader = function() {
  this.writeHead.apply(this, arguments);
};

module.exports = ServerResponse;

},{"./outgoing-message.qtscript":4,"./utils.qtscript":7,"assert":undefined,"util":undefined}],6:[function(require,module,exports){
var assert = require('assert').ok;
var EventEmitter = require('events').EventEmitter;
var net = require('net');
var util = require('util');
var HTTPParser = require('http-parser-js').HTTPParser;

var ServerResponse = require('./server-response.qtscript');
var common = require('./common');

var debug = common.debug;
var freeParser = common.freeParser;
var httpSocketSetup = common.httpSocketSetup;
var kOnExecute = HTTPParser.kOnExecute | 0;
var parsers = common.parsers;

/**
 * Emulate Node.js's `http.Server` class.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/http.html#http_class_http_server
 */
function Server(requestListener) {
  var self = this;

  if (!(this instanceof Server)) return new Server(requestListener);
  net.Server.call(this, { allowHalfOpen: true });

  if (requestListener) {
    this.addListener('request', requestListener);
  }

  /* eslint-disable max-len */
  // Similar option to this. Too lazy to write my own docs.
  // http://www.squid-cache.org/Doc/config/half_closed_clients/
  // http://wiki.squid-cache.org/SquidFaq/InnerWorkings#What_is_a_half-closed_filedescriptor.3F
  /* eslint-enable max-len */
  this.httpAllowHalfOpen = false;

  this.addListener('connection', connectionListener);

  this.addListener('clientError', function(err, conn) {
    conn.destroy(err);
  });

  this.timeout = 2 * 60 * 1000;

  this._pendingResponseData = 0;

  return this;
}
util.inherits(Server, net.Server);

Server.prototype.setTimeout = function(msecs, callback) {
  this.timeout = msecs;
  if (callback)
    this.on('timeout', callback);
  return this;
};

// TODO: Implement parser.
function connectionListener(socket) {
  var self = this;
  var outgoing = [];
  var incoming = [];
  var outgoingData = 0;


  function updateOutgoingData(delta) {
    // `outgoingData` is an approximate amount of bytes queued through all
    // inactive responses. If more data than the high watermark is queued - we
    // need to pause TCP socket/HTTP parser, and wait until the data will be
    // sent to the client.
    outgoingData += delta;
    // Not needed in Qt
    //if (socket._paused && outgoingData < socket._writableState.highWaterMark)
    //  return socketOnDrain();
  }

  function abortIncoming() {
    while (incoming.length) {
      var req = incoming.shift();
      req.emit('aborted');
      req.emit('close');
    }
    // abort socket._httpMessage ?
  }

  function serverSocketCloseListener() {
    debug('server socket close');
    // mark this parser as reusable
    if (this.parser) {
      freeParser(this.parser, null, this);
    }

    abortIncoming();
  }

  debug('SERVER new http connection');

  httpSocketSetup(socket);

  // If the user has added a listener to the server,
  // request, or response, then it's their responsibility.
  // otherwise, destroy on timeout by default
  if (self.timeout)
    socket.setTimeout(self.timeout);

  socket.on('timeout', function() {
    var req = socket.parser && socket.parser.incoming;
    var reqTimeout = req && !req.complete && req.emit('timeout', socket);
    var res = socket._httpMessage;
    var resTimeout = res && res.emit('timeout', socket);
    var serverTimeout = self.emit('timeout', socket);

    if (!reqTimeout && !resTimeout && !serverTimeout)
      socket.destroy();
  });

  var parser = parsers.alloc();
  parser.reinitialize(HTTPParser.REQUEST);
  parser.socket = socket;
  socket.parser = parser;
  parser.incoming = null;

  // Propagate headers limit from server instance to parser
  if (typeof this.maxHeadersCount === 'number') {
    parser.maxHeaderPairs = this.maxHeadersCount << 1;
  } else {
    // Set default value because parser may be reused from FreeList
    parser.maxHeaderPairs = 2000;
  }

  socket.addListener('error', socketOnError);
  socket.addListener('close', serverSocketCloseListener);
  parser.onIncoming = parserOnIncoming;
  socket.on('end', socketOnEnd);
  socket.on('data', socketOnData);

  // We are consuming socket, so it won't get any actual data
  socket.on('resume', onSocketResume);
  socket.on('pause', onSocketPause);

  socket.on('drain', socketOnDrain);

  // Override on to unconsume on `data`, `readable` listeners
  socket.on = socketOnWrap;

  /*
  var external = socket._handle._externalStream;
  if (external) {
    parser._consumed = true;
    parser.consume(external);
  }
  external = null;
  */
  parser[kOnExecute] = onParserExecute;

  // TODO(isaacs): Move all these functions out of here
  function socketOnError(e) {
    self.emit('clientError', e, this);
  }

  function socketOnData(d) {
    assert(!socket._paused);
    debug('SERVER socketOnData %d', d.length);
    var ret = parser.execute(d);

    onParserExecuteCommon(ret, d);
  }

  function onParserExecute(ret, d) {
    debug('SERVER socketOnParserExecute %d', ret);
    onParserExecuteCommon(ret, undefined);
  }

  function onParserExecuteCommon(ret, d) {
    if (ret instanceof Error) {
      debug('parse error');
      socket.destroy(ret);
    } else if (parser.incoming && parser.incoming.upgrade) {
      // Upgrade or CONNECT
      var bytesParsed = ret;
      var req = parser.incoming;
      debug('SERVER upgrade or connect', req.method);

      if (!d)
        d = parser.getCurrentBuffer();

      socket.removeListener('data', socketOnData);
      socket.removeListener('end', socketOnEnd);
      socket.removeListener('close', serverSocketCloseListener);
      unconsume(parser, socket);
      parser.finish();
      freeParser(parser, req, null);
      parser = null;

      var eventName = req.method === 'CONNECT' ? 'connect' : 'upgrade';
      if (EventEmitter.listenerCount(self, eventName) > 0) {
        debug('SERVER have listener for %s', eventName);
        var bodyHead = d.slice(bytesParsed, d.length);

        // TODO(isaacs): Need a way to reset a stream to fresh state
        // IE, not flowing, and not explicitly paused.
        // Not needed in Qt
        //socket._readableState.flowing = null;
        self.emit(eventName, req, socket, bodyHead);
      } else {
        // Got upgrade header or CONNECT method, but have no handler.
        socket.destroy();
      }
    }

    if (socket._paused && socket.parser) {
      // onIncoming paused the socket, we should pause the parser as well
      debug('pause parser');
      socket.parser.pause();
    }
  }

  function socketOnEnd() {
    var socket = this;
    var ret = parser.finish();

    if (ret instanceof Error) {
      debug('parse error');
      socket.destroy(ret);
      return;
    }

    if (!self.httpAllowHalfOpen) {
      abortIncoming();
      if (socket.writable) socket.end();
    } else if (outgoing.length) {
      outgoing[outgoing.length - 1]._last = true;
    } else if (socket._httpMessage) {
      socket._httpMessage._last = true;
    } else {
      if (socket.writable) socket.end();
    }
  }


  // The following callback is issued after the headers have been read on a
  // new message. In this callback we setup the response object and pass it
  // to the user.

  socket._paused = false;
  function socketOnDrain() {
    // Not needed in Qt
    var needPause = false;
    //var needPause = outgoingData > socket._writableState.highWaterMark;

    // If we previously paused, then start reading again.
    if (socket._paused && !needPause) {
      socket._paused = false;
      if (socket.parser)
        socket.parser.resume();
      socket.resume();
    }
  }

  function parserOnIncoming(req, shouldKeepAlive) {
    incoming.push(req);

    // TODO: Do not need this with QTcpSocket.
    // If the writable end isn't consuming, then stop reading
    // so that we don't become overwhelmed by a flood of
    // pipelined requests that may never be resolved.
    /*
    if (!socket._paused) {
      var needPause = socket._writableState.needDrain ||
          outgoingData >= socket._writableState.highWaterMark;
      if (needPause) {
        socket._paused = true;
        // We also need to pause the parser, but don't do that until after
        // the call to execute, because we may still be processing the last
        // chunk.
        socket.pause();
      }
    }
    */

    var res = new ServerResponse(req);
    res._onPendingData = updateOutgoingData;

    res.shouldKeepAlive = shouldKeepAlive;
    //DTRACE_HTTP_SERVER_REQUEST(req, socket);
    //LTTNG_HTTP_SERVER_REQUEST(req, socket);
    //COUNTER_HTTP_SERVER_REQUEST();

    if (socket._httpMessage) {
      // There are already pending outgoing res, append.
      outgoing.push(res);
    } else {
      res.assignSocket(socket);
    }

    // When we're finished writing the response, check if this is the last
    // response, if so destroy the socket.
    res.on('finish', resOnFinish);
    function resOnFinish() {
      // Usually the first incoming element should be our request.  it may
      // be that in the case abortIncoming() was called that the incoming
      // array will be empty.
      assert(incoming.length === 0 || incoming[0] === req);

      incoming.shift();

      // if the user never called req.read(), and didn't pipe() or
      // .resume() or .on('data'), then we call req._dump() so that the
      // bytes will be pulled off the wire.
      // Not needed in Qt
      //if (!req._consuming && !req._readableState.resumeScheduled)
      //  req._dump();

      // Not needed in Qt.
      //res.detachSocket(socket);

      if (res._last) {
        socket.destroySoon();
      } else {
        // start sending the next message
        var m = outgoing.shift();
        if (m) {
          m.assignSocket(socket);
        }
      }
    }

    if (req.headers.expect !== undefined &&
        (req.httpVersionMajor == 1 && req.httpVersionMinor == 1) &&
        continueExpression.test(req.headers['expect'])) {
      res._expect_continue = true;
      if (EventEmitter.listenerCount(self, 'checkContinue') > 0) {
        self.emit('checkContinue', req, res);
      } else {
        res.writeContinue();
        self.emit('request', req, res);
      }
    } else {
      self.emit('request', req, res);
    }
    return false; // Not a HEAD response. (Not even a response!)
  }
}
exports._connectionListener = connectionListener;

function onSocketResume() {
  // It may seem that the socket is resumed, but this is an enemy's trick to
  // deceive us! `resume` is emitted asynchronously, and may be called from
  // `incoming.readStart()`. Stop the socket again here, just to preserve the
  // state.
  //
  // We don't care about stream semantics for the consumed socket anyway.
  if (this._paused) {
    this.pause();
    return;
  }

  if (this._handle && !this._handle.reading) {
    this._handle.reading = true;
    this._handle.readStart();
  }
}

function onSocketPause() {
  if (this._handle && this._handle.reading) {
    this._handle.reading = false;
    this._handle.readStop();
  }
}

function unconsume(parser, socket) {
  if (socket._handle) {
    if (parser._consumed)
      parser.unconsume(socket._handle._externalStream);
    parser._consumed = false;
    socket.removeListener('pause', onSocketPause);
    socket.removeListener('resume', onSocketResume);
  }
}

function socketOnWrap(ev, fn) {
  var res = net.Socket.prototype.on.call(this, ev, fn);
  if (!this.parser) {
    this.on = net.Socket.prototype.on;
    return res;
  }

  if (ev === 'data' || ev === 'readable')
    unconsume(this.parser, this);

  return res;
}

module.exports = Server;

},{"./common":2,"./server-response.qtscript":5,"assert":undefined,"events":undefined,"http-parser-js":8,"net":undefined,"util":undefined}],7:[function(require,module,exports){
var utils = {
  /**
   * Helper function to convert a Qt QByteArray to the encoding format.
   *
   * @param {QByteArray} qba - The QByteArray to convert.
   * @param {String} [encoding] - The encoding can be 'hex', 'binary' or 'base64'.
   *   If no encoding is provided, then a buffer is returned.
   * @return {String | Buffer} - The encoded QByteArray data.
   * @private
   */
  _convertQByteArrayToEncoding: function _convertQByteArrayToEncoding (qba, encoding) {
    var data;
    switch (encoding) {
      case 'base64':
        data = qba.toBase64();
        break;
      case 'binary':
        data = qba.toString();
        break;
      case 'hex':
        data = qba.toHex();
        break;
      case 'utf8':
      case 'utf-8':
      default:
        // Utf8 encode the QByteArray.
        //var encodedQba = new QByteArray(qba.toString());
        var encodedQba = new QByteArray(qba.toLatin1());

        // Node.js's default is a Buffer.
        if (Buffer.fromQByteArray) {
          data = Buffer.fromQByteArray(encodedQba);
        } else {
          var buffer = new Buffer(encodedQba.size());
          var mask = (1 << 8) -1;
          // HEX conversion is slower.
          //var hex = encodedQba.toHex().toString();
          //buffer.write(hex, "hex");
          var size = encodedQba.size();
          for (var i = 0; i < size; i++) {
            buffer[i] = encodedQba.at(i) & mask;
          }
          data = buffer;
        }
    }

    return data;
  },

  STATUS_CODES: {
    100 : 'Continue',
    101 : 'Switching Protocols',
    102 : 'Processing',                 // RFC 2518, obsoleted by RFC 4918
    200 : 'OK',
    201 : 'Created',
    202 : 'Accepted',
    203 : 'Non-Authoritative Information',
    204 : 'No Content',
    205 : 'Reset Content',
    206 : 'Partial Content',
    207 : 'Multi-Status',               // RFC 4918
    208 : 'Already Reported',
    226 : 'IM Used',
    300 : 'Multiple Choices',
    301 : 'Moved Permanently',
    302 : 'Found',
    303 : 'See Other',
    304 : 'Not Modified',
    305 : 'Use Proxy',
    307 : 'Temporary Redirect',
    308 : 'Permanent Redirect',         // RFC 7238
    400 : 'Bad Request',
    401 : 'Unauthorized',
    402 : 'Payment Required',
    403 : 'Forbidden',
    404 : 'Not Found',
    405 : 'Method Not Allowed',
    406 : 'Not Acceptable',
    407 : 'Proxy Authentication Required',
    408 : 'Request Timeout',
    409 : 'Conflict',
    410 : 'Gone',
    411 : 'Length Required',
    412 : 'Precondition Failed',
    413 : 'Payload Too Large',
    414 : 'URI Too Long',
    415 : 'Unsupported Media Type',
    416 : 'Range Not Satisfiable',
    417 : 'Expectation Failed',
    418 : 'I\'m a teapot',              // RFC 2324
    421 : 'Misdirected Request',
    422 : 'Unprocessable Entity',       // RFC 4918
    423 : 'Locked',                     // RFC 4918
    424 : 'Failed Dependency',          // RFC 4918
    425 : 'Unordered Collection',       // RFC 4918
    426 : 'Upgrade Required',           // RFC 2817
    428 : 'Precondition Required',      // RFC 6585
    429 : 'Too Many Requests',          // RFC 6585
    431 : 'Request Header Fields Too Large', // RFC 6585
    500 : 'Internal Server Error',
    501 : 'Not Implemented',
    502 : 'Bad Gateway',
    503 : 'Service Unavailable',
    504 : 'Gateway Timeout',
    505 : 'HTTP Version Not Supported',
    506 : 'Variant Also Negotiates',    // RFC 2295
    507 : 'Insufficient Storage',       // RFC 4918
    508 : 'Loop Detected',
    509 : 'Bandwidth Limit Exceeded',
    510 : 'Not Extended',               // RFC 2774
    511 : 'Network Authentication Required' // RFC 6585
  }
};

module.exports = utils;

},{}],8:[function(require,module,exports){
/*jshint node:true */

var assert = require('assert');

exports.HTTPParser = HTTPParser;
function HTTPParser(type) {
  assert.ok(type === HTTPParser.REQUEST || type === HTTPParser.RESPONSE);
  this.type = type;
  this.state = type + '_LINE';
  this.info = {
    headers: [],
    upgrade: false
  };
  this.trailers = [];
  this.line = '';
  this.isChunked = false;
  this.connection = '';
  this.headerSize = 0; // for preventing too big headers
  this.body_bytes = null;
  this.isUserCall = false;
  this.hadError = false;
}
HTTPParser.maxHeaderSize = 80 * 1024; // maxHeaderSize (in bytes) is configurable, but 80kb by default;
HTTPParser.REQUEST = 'REQUEST';
HTTPParser.RESPONSE = 'RESPONSE';
var kOnHeaders = HTTPParser.kOnHeaders = 0;
var kOnHeadersComplete = HTTPParser.kOnHeadersComplete = 1;
var kOnBody = HTTPParser.kOnBody = 2;
var kOnMessageComplete = HTTPParser.kOnMessageComplete = 3;

var compatMode0_12 = true;
Object.defineProperty(HTTPParser, 'kOnExecute', {
    get: function () {
      // hack for backward compatibility
      compatMode0_12 = false;
      return 4;
    }
  });

var methods = exports.methods = HTTPParser.methods = [
  'DELETE',
  'GET',
  'HEAD',
  'POST',
  'PUT',
  'CONNECT',
  'OPTIONS',
  'TRACE',
  'COPY',
  'LOCK',
  'MKCOL',
  'MOVE',
  'PROPFIND',
  'PROPPATCH',
  'SEARCH',
  'UNLOCK',
  'BIND',
  'REBIND',
  'UNBIND',
  'ACL',
  'REPORT',
  'MKACTIVITY',
  'CHECKOUT',
  'MERGE',
  'M-SEARCH',
  'NOTIFY',
  'SUBSCRIBE',
  'UNSUBSCRIBE',
  'PATCH',
  'PURGE',
  'MKCALENDAR',
  'LINK',
  'UNLINK'
];
HTTPParser.prototype.reinitialize = HTTPParser;
HTTPParser.prototype.close =
HTTPParser.prototype.pause =
HTTPParser.prototype.resume = function () {};
HTTPParser.prototype._compatMode0_11 = false;

var headerState = {
  REQUEST_LINE: true,
  RESPONSE_LINE: true,
  HEADER: true
};
HTTPParser.prototype.execute = function (chunk, start, length) {
  if (!(this instanceof HTTPParser)) {
    throw new TypeError('not a HTTPParser');
  }

  // backward compat to node < 0.11.4
  // Note: the start and length params were removed in newer version
  start = start || 0;
  length = typeof length === 'number' ? length : chunk.length;

  this.chunk = chunk;
  this.offset = start;
  var end = this.end = start + length;
  try {
    while (this.offset < end) {
      if (this[this.state]()) {
        break;
      }
    }
  } catch (err) {
    if (this.isUserCall) {
      throw err;
    }
    this.hadError = true;
    return err;
  }
  this.chunk = null;
  length = this.offset - start;
  if (headerState[this.state]) {
    this.headerSize += length;
    if (this.headerSize > HTTPParser.maxHeaderSize) {
      return new Error('max header size exceeded');
    }
  }
  return length;
};

var stateFinishAllowed = {
  REQUEST_LINE: true,
  RESPONSE_LINE: true,
  BODY_RAW: true
};
HTTPParser.prototype.finish = function () {
  if (this.hadError) {
    return;
  }
  if (!stateFinishAllowed[this.state]) {
    return new Error('invalid state for EOF');
  }
  if (this.state === 'BODY_RAW') {
    this.userCall()(this[kOnMessageComplete]());
  }
};

// These three methods are used for an internal speed optimization, and it also
// works if theses are noops. Basically consume() asks us to read the bytes
// ourselves, but if we don't do it we get them through execute().
HTTPParser.prototype.consume =
HTTPParser.prototype.unconsume =
HTTPParser.prototype.getCurrentBuffer = function () {};

//For correct error handling - see HTTPParser#execute
//Usage: this.userCall()(userFunction('arg'));
HTTPParser.prototype.userCall = function () {
  this.isUserCall = true;
  var self = this;
  return function (ret) {
    self.isUserCall = false;
    return ret;
  };
};

HTTPParser.prototype.nextRequest = function () {
  this.userCall()(this[kOnMessageComplete]());
  this.reinitialize(this.type);
};

HTTPParser.prototype.consumeLine = function () {
  var end = this.end,
      chunk = this.chunk;
  for (var i = this.offset; i < end; i++) {
    if (chunk[i] === 0x0a) { // \n
      var line = this.line + chunk.toString('ascii', this.offset, i);
      if (line.charAt(line.length - 1) === '\r') {
        line = line.substr(0, line.length - 1);
      }
      this.line = '';
      this.offset = i + 1;
      return line;
    }
  }
  //line split over multiple chunks
  this.line += chunk.toString('ascii', this.offset, this.end);
  this.offset = this.end;
};

var headerExp = /^([^: \t]+):[ \t]*((?:.*[^ \t])|)/;
var headerContinueExp = /^[ \t]+(.*[^ \t])/;
HTTPParser.prototype.parseHeader = function (line, headers) {
  if (line.indexOf('\r') !== -1) {
    throw parseErrorCode('HPE_LF_EXPECTED');
  }

  var match = headerExp.exec(line);
  var k = match && match[1];
  if (k) { // skip empty string (malformed header)
    headers.push(k);
    headers.push(match[2]);
  } else {
    var matchContinue = headerContinueExp.exec(line);
    if (matchContinue && headers.length) {
      if (headers[headers.length - 1]) {
        headers[headers.length - 1] += ' ';
      }
      headers[headers.length - 1] += matchContinue[1];
    }
  }
};

var requestExp = /^([A-Z-]+) ([^ ]+) HTTP\/(\d)\.(\d)$/;
HTTPParser.prototype.REQUEST_LINE = function () {
  var line = this.consumeLine();
  if (!line) {
    return;
  }
  var match = requestExp.exec(line);
  if (match === null) {
    throw parseErrorCode('HPE_INVALID_CONSTANT');
  }
  this.info.method = this._compatMode0_11 ? match[1] : methods.indexOf(match[1]);
  if (this.info.method === -1) {
    throw new Error('invalid request method');
  }
  if (match[1] === 'CONNECT') {
    this.info.upgrade = true;
  }
  this.info.url = match[2];
  this.info.versionMajor = +match[3];
  this.info.versionMinor = +match[4];
  this.body_bytes = 0;
  this.state = 'HEADER';
};

var responseExp = /^HTTP\/(\d)\.(\d) (\d{3}) ?(.*)$/;
HTTPParser.prototype.RESPONSE_LINE = function () {
  var line = this.consumeLine();
  if (!line) {
    return;
  }
  var match = responseExp.exec(line);
  if (match === null) {
    throw parseErrorCode('HPE_INVALID_CONSTANT');
  }
  this.info.versionMajor = +match[1];
  this.info.versionMinor = +match[2];
  var statusCode = this.info.statusCode = +match[3];
  this.info.statusMessage = match[4];
  // Implied zero length.
  if ((statusCode / 100 | 0) === 1 || statusCode === 204 || statusCode === 304) {
    this.body_bytes = 0;
  }
  this.state = 'HEADER';
};

HTTPParser.prototype.shouldKeepAlive = function () {
  if (this.info.versionMajor > 0 && this.info.versionMinor > 0) {
    if (this.connection.indexOf('close') !== -1) {
      return false;
    }
  } else if (this.connection.indexOf('keep-alive') === -1) {
    return false;
  }
  if (this.body_bytes !== null || this.isChunked) { // || skipBody
    return true;
  }
  return false;
};

HTTPParser.prototype.HEADER = function () {
  var line = this.consumeLine();
  if (line === undefined) {
    return;
  }
  var info = this.info;
  if (line) {
    this.parseHeader(line, info.headers);
  } else {
    var headers = info.headers;
    var hasContentLength = false;
    for (var i = 0; i < headers.length; i += 2) {
      switch (headers[i].toLowerCase()) {
        case 'transfer-encoding':
          this.isChunked = headers[i + 1].toLowerCase() === 'chunked';
          break;
        case 'content-length':
          if (hasContentLength) {
            throw parseErrorCode('HPE_UNEXPECTED_CONTENT_LENGTH');
          }
          hasContentLength = true;
          this.body_bytes = +headers[i + 1];
          break;
        case 'connection':
          this.connection += headers[i + 1].toLowerCase();
          break;
        case 'upgrade':
          info.upgrade = true;
          break;
      }
    }

    if (this.isChunked && hasContentLength) {
      throw parseErrorCode('HPE_UNEXPECTED_CONTENT_LENGTH');
    }

    info.shouldKeepAlive = this.shouldKeepAlive();
    //problem which also exists in original node: we should know skipBody before calling onHeadersComplete
    var skipBody;
    if (compatMode0_12) {
      skipBody = this.userCall()(this[kOnHeadersComplete](info));
    } else {
      skipBody = this.userCall()(this[kOnHeadersComplete](info.versionMajor,
          info.versionMinor, info.headers, info.method, info.url, info.statusCode,
          info.statusMessage, info.upgrade, info.shouldKeepAlive));
    }
    if (info.upgrade || skipBody === 2) {
      this.nextRequest();
      return true;
    } else if (this.isChunked && !skipBody) {
      this.state = 'BODY_CHUNKHEAD';
    } else if (skipBody || this.body_bytes === 0) {
      this.nextRequest();
    } else if (this.body_bytes === null) {
      this.state = 'BODY_RAW';
    } else {
      this.state = 'BODY_SIZED';
    }
  }
};

HTTPParser.prototype.BODY_CHUNKHEAD = function () {
  var line = this.consumeLine();
  if (line === undefined) {
    return;
  }
  this.body_bytes = parseInt(line, 16);
  if (!this.body_bytes) {
    this.state = 'BODY_CHUNKTRAILERS';
  } else {
    this.state = 'BODY_CHUNK';
  }
};

HTTPParser.prototype.BODY_CHUNK = function () {
  var length = Math.min(this.end - this.offset, this.body_bytes);
  this.userCall()(this[kOnBody](this.chunk, this.offset, length));
  this.offset += length;
  this.body_bytes -= length;
  if (!this.body_bytes) {
    this.state = 'BODY_CHUNKEMPTYLINE';
  }
};

HTTPParser.prototype.BODY_CHUNKEMPTYLINE = function () {
  var line = this.consumeLine();
  if (line === undefined) {
    return;
  }
  assert.equal(line, '');
  this.state = 'BODY_CHUNKHEAD';
};

HTTPParser.prototype.BODY_CHUNKTRAILERS = function () {
  var line = this.consumeLine();
  if (line === undefined) {
    return;
  }
  if (line) {
    this.parseHeader(line, this.trailers);
  } else {
    if (this.trailers.length) {
      this.userCall()(this[kOnHeaders](this.trailers, ''));
    }
    this.nextRequest();
  }
};

HTTPParser.prototype.BODY_RAW = function () {
  var length = this.end - this.offset;
  this.userCall()(this[kOnBody](this.chunk, this.offset, length));
  this.offset = this.end;
};

HTTPParser.prototype.BODY_SIZED = function () {
  var length = Math.min(this.end - this.offset, this.body_bytes);
  this.userCall()(this[kOnBody](this.chunk, this.offset, length));
  this.offset += length;
  this.body_bytes -= length;
  if (!this.body_bytes) {
    this.nextRequest();
  }
};

// backward compat to node < 0.11.6
['Headers', 'HeadersComplete', 'Body', 'MessageComplete'].forEach(function (name) {
  var k = HTTPParser['kOn' + name];
  Object.defineProperty(HTTPParser.prototype, 'on' + name, {
    get: function () {
      return this[k];
    },
    set: function (to) {
      // hack for backward compatibility
      this._compatMode0_11 = true;
      return (this[k] = to);
    }
  });
});

function parseErrorCode(code) {
  var err = new Error('Parse Error');
  err.code = code;
  return err;
}

},{"assert":undefined}],"http":[function(require,module,exports){
var common = require('./common');
var ClientRequest = require('./client-request.qtscript');
var ClientIncomingMessage = require('./incoming-message.qtscript').ClientIncomingMessage;
var IncomingMessage = require('./incoming-message.qtscript').ServerIncomingMessage;
var Server = require('./server.qtscript');
var ServerResponse = require('./server-response.qtscript');
var utils = require('./utils.qtscript');

var http = {
  Agent: null,
  ClientRequest: ClientRequest,
  Server: Server,
  ServerResponse: ServerResponse,
  IncomingMessage: IncomingMessage,
  ClientIncomingMessage: ClientIncomingMessage,
  METHODS: common.methods.slice().sort(),
  STATUS_CODES: utils.STATUS_CODES,
  createClient: null,
  createServer: function(requestListener) {
    return new Server(requestListener);
  },
  get: function(options, cb) {
    options.method = 'GET';
    var req = this.request(options, cb);
    req.end();
    return req;
  },
  globalAgent: null,
  request: function(options, cb) {
    return new ClientRequest(options, cb);
  }
};

module.exports = http;

},{"./client-request.qtscript":1,"./common":2,"./incoming-message.qtscript":3,"./server-response.qtscript":5,"./server.qtscript":6,"./utils.qtscript":7}]},{},[]); 
$code_body$::text); 
