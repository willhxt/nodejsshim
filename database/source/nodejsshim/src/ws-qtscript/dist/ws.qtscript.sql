--DO NOT EDIT THIS FILE! This file is generated by running the 'npm run build' command from this repos root. 
SELECT nodejsshim.npm_install('nodejsshim'::text, 'ws'::text, '1.0.0-rc'::text, 'https://github.com/xtuple/qt-script-node-js-shims'::text, $code_body$ 
require=(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var http = require('http');
var stream = require('stream');
var util = require('util');

var utils = require('./utils.qtscript');

/**
 * Emulate Node.js's ws.WebSocket class using Qt's QWebSocket class.
 * @See: https://github.com/websockets/ws/blob/1.1.0/doc/ws.md#class-wswebsocket
 *
 * @param {String} address - The socket connection options.
 * @param {String | Array | Object} [protocols] - The WebSocket protocols. This parameter is not supported by QWebSocket.
 * @param {Object} [options] - The WebSocket options.
 */
var WebSocket = function webSocketConstructor (address, protocols, options) {
  if (this instanceof WebSocket === false) {
    return new WebSocket(address, protocols, options);
  }

  EventEmitter.call(this);

  if (protocols && !Array.isArray(protocols) && 'object' === typeof protocols) {
    // Accept the "options" Object as the 2nd argument.
    options = protocols;
    protocols = null;
  }

  options = options || {};

  // If this is an incoming client WebSocket on the WebSocketServer.
  if (Array.isArray(address)) {
    options.QWebSocket = address[0];

    if (options._server) {
      this._server = options._server;
      this._isServer = true;
      // @See: https://github.com/websockets/ws/blob/1.1.0/doc/ws.md#websocketurl
      this.url = this._server.QWebSocketServer ? this._server.QWebSocketServer.serverUrl().toString() : 'unknown';
    }

    // @See: https://github.com/websockets/ws/blob/1.1.0/doc/ws.md#websocketupgradereq
    // TODO: `QWebSocket.request()` wasn't added until Qt 5.6.
    //this.upgradeReq = new http.ClientIncomingMessage(function () {}, options.QWebSocket.request());

    // Mock up a `req` object for minimal authentication used by WebSocketServer
    // when passed a `verifyClient` callback option.
    this.upgradeReq = {
      headers: [],
      rawHeaders: [],
      url: options.QWebSocket.requestUrl().toString()
    };
  }

  this.options = {
    readable: false,
    writable: false,
  };

  this.options = Object.assign(this.options, options);

  if (options.QWebSocket) {
    this.QWebSocket = options.QWebSocket;
  } else {
    this.QWebSocket = new QWebSocket("", QWebSocketProtocol.VersionLatest, new QObject(mywindow));
  }

  this.QWebSocket["textMessageReceived(const QString &)"].connect(_isTextMessageReceived);

  this.QWebSocket["bytesWritten(qint64)"].connect(_isBytesWritten);
  this.QWebSocket["binaryFrameReceived(const QByteArray &, bool)"].connect(_isBinaryFrameReceived);
  this.QWebSocket["binaryMessageReceived(const QByteArray &)"].connect(_isBinaryMessageReceived);
  this.QWebSocket["connected()"].connect(_isConnected);
  this.QWebSocket["disconnected()"].connect(_isDisconnected);
  this.QWebSocket["error(QAbstractSocket::SocketError)"].connect(_isError);
  this.QWebSocket["pong(quint64, const QByteArray &)"].connect(_isPong);
  this.QWebSocket["textFrameReceived(const QString &, bool)"].connect(_isTextFrameReceived);

  this.bytesReceived = 0;
  this.protocolVersion = this.QWebSocket.version();
  this.supports = {
    binary: (this.protocolVersion > 0)
  };
  this._binaryType = 'nodebuffer';

  this.remoteAddress = null;
  this.remotePort = null;
  this.localAddress = null;
  this.localPort = null;
  this.bytesWritten = 0;
  this._closing = false;
  this._connecting = false;
  this.readable = false;
  this.writable = false;
  this._encoding = null;
  this._binaryFrames = [];
  this._textFrames = [];

  var self = this;

  function _isBytesWritten(bytes) {
    self.bytesWritten = self.bytesWritten + bytes;
    self.emit('drain');
  }
  function _isBinaryFrameReceived (frame, isLastFrame) {
    // TODO: It appears both `binaryMessageReceived` and `binaryFrameReceived` are called.
    /*
    self._binaryFrames.push(frame);

    if (isLastFrame) {
      var data = utils._convertQByteArrayToEncoding(self._binaryFrames.join(''), self._encoding);
      self.bytesReceived += data.length;
      self.emit('message', data);
      self._binaryFrames = [];
    }
    */
  }
  function _isBinaryMessageReceived (message) {
    var data = utils._convertQByteArrayToEncoding(message, self._encoding);
    self.bytesReceived += data.length;
    self.emit('message', data);
  }
  function _isConnected () {
    self._connecting = false;
    self.readable = true;
    self.writable = true;
    self.localAddress = self.QWebSocket.localAddress().toString();
    self.localPort = self.QWebSocket.localPort();
    self.remoteAddress = self.QWebSocket.peerAddress().toString();
    self.remotePort = self.QWebSocket.peerPort();
    self.emit('connect');
  }
  function _isDisconnected () {
    self._connecting = false;
    self.readable = false;
    self.writable = false;
    self._closing = false;
    self._closed = true;
    self.emit('end');
    self.emit('close', false);
  }
  function _isError (socketError) {
    if (socketError === 1) {
      // This is just `QAbstractSocket::RemoteHostClosedError`, so ignore it.
      // The remote host closed the connection. Note that the client socket
      // (i.e., this socket) will be closed after the remote close notification
      // has been sent.
      // @See: https://doc.qt.io/qt-5/qabstractsocket.html#SocketError-enum
      return;
    }
    if (socketError === 5) {
      return;
    }

    var err = {
      message: "enum QAbstractSocket::SocketError code: " + socketError
    };
    self._closing = false;
    self.emit('error', err);
    self.emit('close', true);
  }
  function _isPong(elapsedTime, payload) {
    var data = utils._convertQByteArrayToEncoding(payload, self._encoding);
    self.emit('pong', data, {binary: true});
  }
  function _isTextFrameReceived (frame, isLastFrame) {
    // TODO: It appears both `textMessageReceived` and `textFrameReceived` are called.
    /*
    self._textFrames.push(frame);

    if (isLastFrame) {
      var data = self._textFrames.join('');
      self.bytesReceived += data.length;
      self.emit('message', data);
      self._textFrames = [];
    }
    */
  }
  function _isTextMessageReceived (message) {
    self.emit('message', message);
    self.bytesReceived += message.length;
  }

  if (!Array.isArray(address)) {
    this.on('connect', function isConnected () {
      self.emit('open');
    });
    this.QWebSocket.open(QUrl(address));
  }
};

util.inherits(WebSocket, EventEmitter);

["CONNECTING", "OPEN", "CLOSING", "CLOSED"].forEach(function each(state, index) {
    WebSocket.prototype[state] = WebSocket[state] = index;
});

/*
 * @See: https://github.com/websockets/ws/blob/1.1.0/doc/ws.md#websocketreadystate
 */
Object.defineProperty(WebSocket.prototype, 'readyState', {
  get: function() {
    if (this._connecting) {
      return WebSocket.CONNECTING;
    } else if (this.readable && this.writable) {
      return WebSocket.OPEN;
    } else if (this._closing) {
      return WebSocket.CLOSING;
    } else {
      return WebSocket.CLOSED;
    }
  }
});

/**
 * Emulate Node.js's `websocket.close([code], [data])` method.
 * @See: https://github.com/websockets/ws/blob/1.1.0/doc/ws.md#websocketclosecode-data
 *
 * @param {Number} [code] - The WebSocket close code to use.
 * @param {String | Buffer} [data] - If set, passed to `WebSocket.send(data, encoding);` before closing.
 */
WebSocket.prototype.close = function close (code, data) {
  var self = this;

  if (this.readyState === WebSocket.CLOSED) {
    return;
  }

  function sendAndClode () {
    self._closing = true;
    if (data) {
      self.send(data, function () {
        self.QWebSocket.close(code);
      });
    } else {
      self.QWebSocket.close(code);
    }
  }

  try {
    if (this.readyState === WebSocket.CONNECTING) {
      if (this.QWebSocket.isValid()) {
        sendAndClode();
      } else {
        this._connecting = false;
        this._closed = true;
      }
    } else if (this.readyState === WebSocket.CLOSING) {
      if (this._isServer) {
        this.terminate();
      }
    } else {this._closing = true;
      sendAndClode();
    }

    return;
  } catch (e) {
    this.emit('error', e);
  }
};

/**
 * Emulate Node.js's `websocket.pause()` method.
 * @See: https://github.com/websockets/ws/blob/1.1.0/doc/ws.md#websocketpause
 */
WebSocket.prototype.pause = function pause () {
  // We cannot support pausing the socket. Qt only allows for QAbstractSocket::PauseOnSslErrors.
  console.warn("websocket.pause() is not supported by Qt's QWebSocket.");
};

/**
 * Emulate Node.js's `websocket.ping([data], [options], [dontFailWhenClosed])` method.
 * @See: https://github.com/websockets/ws/blob/1.1.0/doc/ws.md#websocketpingdata-options-dontfailwhenclosed
 */
WebSocket.prototype.ping = function ping (data, options, dontFailWhenClosed) {
  if (this.readyState !== WebSocket.OPEN) {
    if (dontFailWhenClosed === true) {
      return;
    }
    throw new Error('not opened');
  }

  options = options || {};
  var payload = QByteArray();

  if (data) {
    if (options.binary) {
      payload = utils._convertEncodingToQByteArray(data, this._encoding);
    } else {
      payload = QByteArray(data);
    }
  }

  this.QWebSocket.ping(payload);
};

/**
 * Emulate Node.js's `websocket.pong([data], [options], [dontFailWhenClosed])` method.
 * @See: https://github.com/websockets/ws/blob/1.1.0/doc/ws.md#websocketpongdata-options-dontfailwhenclosed
 */
WebSocket.prototype.pong = function pong (data, options, dontFailWhenClosed) {
  if (this.readyState !== WebSocket.OPEN) {
    if (dontFailWhenClosed === true) {
      return;
    }
    throw new Error('not opened');
  }

  // TODO: Can we support pong? It's a signal.
  console.warn("websocket.pong() is not supported Qt's QWebSocket.");
};

/**
 * Emulate Node.js's `websocket.resume()` method.
 * @See: https://github.com/websockets/ws/blob/1.1.0/doc/ws.md#websocketresume
 */
WebSocket.prototype.resume = function resume () {
  if (this.readyState !== WebSocket.OPEN) {
    throw new Error('not opened');
  }

  this.QWebSocket.resume();
};

/**
 * Emulate Node.js's `websocket.send(data, [options], [callback])` method.
 * @See: https://github.com/websockets/ws/blob/1.1.0/doc/ws.md#websocketsenddata-options-callback
 *
 * @param {String | Buffer} [data] - The data to write to the socket.
 * @param {String | Function} [encoding] - The encoding for the data.
 * @param {Function} [callback] - Callback will be executed when the data is
 *   finally written out - this may not be immediately.
 */
WebSocket.prototype.send = function send (data, options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  if (this.readyState !== WebSocket.OPEN) {
    if (typeof callback === 'function') {
      callback(new Error('not opened'));
    } else {
      throw new Error('not opened');
    }
    return;
  }

  if (!data) {
    data = '';
  }

  if (this._queue) {
    var self = this;
    this._queue.push(function() {
      self.send(data, options, cb);
    });
    return;
  }

  var written = -1;
  options = options || {};
  options.fin = true;

  if (typeof options.binary === 'undefined') {
    // TODO: Will need to add other types if the JS Engine ever supports them. `ArrayBuffer` etc.
    options.binary = data instanceof Buffer;
  }

  var readable = typeof stream.Readable === 'function'
    ? stream.Readable
    : stream.Stream;

  if (data instanceof readable) {
    startQueue(this);
    var self = this;

    sendStream(this, data, options, function send(error) {
      process.nextTick(function tock() {
        executeQueueSends(self);
      });

      if (typeof callback === 'function') {
        callback(error);
      }
    });

    return true;
  } else {
    if (typeof callback === 'function') {
      this.once('drain', callback);
    }
    written = this._sendData(data);

    return 0 < written;
  }
};

/**
 * Emulate Node.js's `websocket.stream([options], callback)` method.
 * @See: https://github.com/websockets/ws/blob/1.1.0/doc/ws.md#websocketstreamoptions-callback
 */
WebSocket.prototype.stream = function stream (options, callback) {
  if (typeof options === 'function') {
    callback = options;
    options = {};
  }

  var self = this;

  if (typeof callback !== 'function') {
    throw new Error('callback must be provided');
  }

  if (this.readyState !== WebSocket.OPEN) {
    if (typeof callback === 'function') {
      callback(new Error('not opened'));
    } else {
      throw new Error('not opened');
    }
    return;
  }

  if (this._queue) {
    this._queue.push(function () {
      self.stream(options, callback);
    });
    return;
  }

  options = options || {};

  startQueue(this);

  function send(data, final) {
    try {
      if (self.readyState !== WebSocket.OPEN) {
        throw new Error('not opened');
      }
      options.fin = final === true;

      self._sendData(data);
      if (!final) {
        process.nextTick(callback.bind(null, null, send));
      } else {
        executeQueueSends(self);
      }
    } catch (e) {
      if (typeof callback === 'function') {
        callback(e);
      } else {
        delete self._queue;
        self.emit('error', e);
      }
    }
  }

  process.nextTick(callback.bind(null, null, send));
};

/**
 * Emulate Node.js's `websocket.terminate()` method.
 * @See: https://github.com/websockets/ws/blob/1.1.0/doc/ws.md#websocketterminate
 */
WebSocket.prototype.terminate = function terminate () {
  this._closing = true;
  this.QWebSocket.abort();
};

/**
 * Private helper function that sends the data on the QWebSocket.
 *
 * @private
 */
WebSocket.prototype._sendData = function _sendData (data) {
  var written = 0;

  if (typeof data === 'string') {
    written = this.QWebSocket.sendTextMessage(data);
  } else if (data instanceof Buffer === true) {
    var qba = utils._convertEncodingToQByteArray(data, this._encoding);
    written = this.QWebSocket.sendBinaryMessage(qba);
  }

  return written;
};

/**
 * Expose binaryType
 *
 * This deviates from the W3C interface since ws doesn't support the required
 * default "blob" type (instead we define a custom "nodebuffer" type).
 *
 * @See: http://dev.w3.org/html5/websockets/#the-websocket-interface
 * @api public
 */
Object.defineProperty(WebSocket.prototype, 'binaryType', {
  get: function get() {
    return this._binaryType;
  },
  set: function set(type) {
    if (type === 'arraybuffer' || type === 'nodebuffer') {
      this._binaryType = type;
    } else {
      throw new SyntaxError('unsupported binaryType: must be either "nodebuffer" or "arraybuffer"');
    }
  }
});

/**
 * Emulates the W3C Browser based WebSocket interface using function members.
 *
 * @See: http://dev.w3.org/html5/websockets/#the-websocket-interface
 * @See: https://github.com/websockets/ws/blob/1.1.0/doc/ws.md#websocketonopen
 * @api public
 */
['open', 'error', 'close', 'message'].forEach(function(method) {
  Object.defineProperty(WebSocket.prototype, 'on' + method, {
    /**
     * Returns the current listener
     *
     * @returns {Mixed} the set function or undefined
     * @api public
     */
    get: function get() {
      var listener = this.listeners(method)[0];
      return listener ? (listener._listener ? listener._listener : listener) : undefined;
    },

    /**
     * Start listening for events
     *
     * @param {Function} listener the listener
     * @returns {Mixed} the set function or undefined
     * @api public
     */
    set: function set(listener) {
      this.removeAllListeners(method);
      this.addEventListener(method, listener);
    }
  });
});

/**
 * Emulates the W3C Browser based WebSocket interface using addEventListener.
 *
 * @See: https://developer.mozilla.org/en/DOM/element.addEventListener
 * @See: http://dev.w3.org/html5/websockets/#the-websocket-interface
 * @See: https://github.com/websockets/ws/blob/1.1.0/doc/ws.md#websocketaddeventlistenermethod-listener
 * @api public
 */
WebSocket.prototype.addEventListener = function(method, listener) {
  var target = this;

  function onMessage (data, flags) {
    // TODO: Support other buffer types when the JS Engine does.
    //if (flags.binary && this.binaryType === 'arraybuffer') {
    //  data = new Uint8Array(data).buffer;
    //}
    listener.call(target, new MessageEvent(data, !!flags.binary, target));
  }

  function onClose (code, message) {
    listener.call(target, new CloseEvent(code, message, target));
  }

  function onError (event) {
    event.type = 'error';
    event.target = target;
    listener.call(target, event);
  }

  function onOpen () {
    listener.call(target, new OpenEvent(target));
  }

  if (typeof listener === 'function') {
    if (method === 'message') {
      // store a reference so we can return the original function from the
      // addEventListener hook
      onMessage._listener = listener;
      this.on(method, onMessage);
    } else if (method === 'close') {
      // store a reference so we can return the original function from the
      // addEventListener hook
      onClose._listener = listener;
      this.on(method, onClose);
    } else if (method === 'error') {
      // store a reference so we can return the original function from the
      // addEventListener hook
      onError._listener = listener;
      this.on(method, onError);
    } else if (method === 'open') {
      // store a reference so we can return the original function from the
      // addEventListener hook
      onOpen._listener = listener;
      this.on(method, onOpen);
    } else {
      this.on(method, listener);
    }
  }
};

/**
 * W3C MessageEvent
 *
 * @See: http://www.w3.org/TR/html5/comms.html
 * @constructor
 * @api private
 */
function MessageEvent(dataArg, isBinary, target) {
  this.type = 'message';
  this.data = dataArg;
  this.target = target;
  this.binary = isBinary; // non-standard.
}

/**
 * W3C CloseEvent
 *
 * @See: http://www.w3.org/TR/html5/comms.html
 * @constructor
 * @api private
 */
function CloseEvent(code, reason, target) {
  this.type = 'close';
  this.wasClean = (typeof code === 'undefined' || code === 1000);
  this.code = code;
  this.reason = reason;
  this.target = target;
}

/**
 * W3C OpenEvent
 *
 * @See: http://www.w3.org/TR/html5/comms.html
 * @constructor
 * @api private
 */
function OpenEvent(target) {
  this.type = 'open';
  this.target = target;
}

function startQueue(instance) {
  instance._queue = instance._queue || [];
}

function executeQueueSends(instance) {
  var queue = instance._queue;
  if (typeof queue === 'undefined') {
    return;
  }

  delete instance._queue;
  for (var i = 0, l = queue.length; i < l; ++i) {
    queue[i]();
  }
}

function sendStream(instance, stream, options, cb) {
  stream.on('data', function incoming(data) {
    if (instance.readyState !== WebSocket.OPEN) {
      if (typeof cb === 'function') {
        cb(new Error('not opened'));
      } else {
        delete instance._queue;
        instance.emit('error', new Error('not opened'));
      }
      return;
    }

    options.fin = false;
    instance._sendData(data);
  });

  stream.on('end', function end() {
    if (instance.readyState !== WebSocket.OPEN) {
      if (typeof cb === 'function') cb(new Error('not opened'));
      else {
        delete instance._queue;
        instance.emit('error', new Error('not opened'));
      }
      return;
    }

    options.fin = true;
    instance._sendData(null);

    if (typeof cb === 'function') {
      cb(null);
    }
  });
}

module.exports = WebSocket;

},{"./utils.qtscript":3,"events":undefined,"http":undefined,"stream":undefined,"util":undefined}],2:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var http = require('http');
var util = require('util');
var url = require('url');

var WebSocket = require('./WebSocket.qtscript');

/**
 * Emulate Node.js's ws.Server class using Qt's QWebSocketServer class.
 * @See: https://github.com/websockets/ws/blob/1.1.0/doc/ws.md#class-wsserver
 *
 * @param {Object} [options] - The WebSocket Server options.
 * @param {Function} [callback] - The connection callback.
 */
var WebSocketServer = function webSocketServerConstructor (options, callback) {
  if (!(this instanceof WebSocketServer)) {
    return new WebSocketServer(options, callback);
  }

  EventEmitter.call(this);

  var self = this;

  if (typeof options === 'function') {
    callback = options;
    options = {};
  } else {
    options = options || {};
  }

  this.options = {
    clientTracking: true,
    //disableHixie: false,
    //handleProtocols: null,
    host: '0.0.0.0',
    //maxPayload: null,
    name: 'xTuple WebSocket Server',
    //noServer: false,
    path: null,
    //perMessageDeflate: true,
    port: null,
    secureMode: false, // TODO: Default to secureMode = true once we figure out SSL.
    cert: null,
    key: null,
    server: null,
    verifyClient: null
  };

  this.options = Object.assign(this.options, options);
  this.options.allowedOrigins = Array.prototype.concat(["localhost"], (options.allowedOrigins ? options.allowedOrigins : []));

  var secureMode = options.secureMode ? QWebSocketServer.SecureMode : QWebSocketServer.NonSecureMode;

  this.QWebSocketServer = new QWebSocketServer(options.name, secureMode, mywindow);

  if (options.secureMode) {
    if (!options.cert || !options.key) {
      var startError = {
        message: "No SSL Certificate or PrivateKey supplied in the configuration options."
      };
      console.warn("WebSocket Server SecureMode Error: " + startError.message);
      this.emit('error', startError);
    }

    QSslSocket.addDefaultCaCertificate(QSslCertificate(options.cert));
    var sslConfiguration = QSslConfiguration();
    sslConfiguration.setPeerVerifyMode(QSslSocket.VerifyNone);
    sslConfiguration.setLocalCertificate(QSslCertificate(options.cert));
    sslConfiguration.setPrivateKey(QSslKey(options.key, QSsl.Rsa));
    sslConfiguration.setProtocol(QSsl.TlsV1SslV3);
    this.QWebSocketServer.setSslConfiguration(sslConfiguration);
  }

  this.maxConnections = options.maxConnections;
  this._connections = 0;
  if (this.maxConnections) {
    this.QWebSocketServer.setMaxPendingConnections(this.maxConnections);
  }

  this.path = options.path;
  this.clients = [];
  this.clientOrigin = null;

  /**
   * Handle new WebSocket client connection error.
   */
  function _isAcceptError (socketError) {
    var err = {
      message: "sOnAcceptError: " + socketError
    };
    self.emit('error', err);
  }

  /**
   * Handle new WebSocket client connection.
   */
  function _isNewConnection () {
    self._handleConnection();
  }
  /**
   * Handle new WebSocket client OriginAuthenticationRequired.
   *
   * We only allow the WebSocket Server's host, "127.0.0.1", and whatever is passed
   * in as options.allowedOrigins. This is to prevent Cross Site Scripting requests
   * reaching this WebSocket Server.
   */
  function _isOriginAuthenticationRequired (authenticator) {
    // TODO: There is a possible race condition from multiple clients
    // setting `self.clientOrigin` below. This code do not have that issue,
    // but it is not configurable from userland code. If this doesn't work out
    // fall back to using it. See `WebSocketServer.prototype._handleConnection`
    // which passed the `self.clientOrigin` to a `verifyClient` callback.
    /*
    var originUrl = new QUrl(authenticator.toString());
    var allowedOrigins = self.options.allowedOrigins.concat(self._host);

    // TODO: Should we allow scheme `file://` access?
    if ((originUrl.length) && allowedOrigins.indexOf(originUrl.host()) === -1 && (originUrl.scheme() !== "file")) {
      authenticator.setAllowed(false);
      console.warn("_isOriginAuthenticationRequired: WebSocket Client Origin " + authenticator.toString() + " is not allowed to access this server.");
    }
    */

    self.clientOrigin = authenticator.origin();
  }

  /**
   * Handle new WebSocket client PeerVerifyError.
   */
  function _isPeerVerifyError (error) {
    var err = {
      message: "sOnPeerVerifyError: " + error
    };
    self.emit('error', err);
  }

  /**
   * Handle new WebSocket client ServerError.
   */
  function _isServerError (closeCode) {
    var err = {
      message: "sOnServerError: " + closeCode
    };
    self.emit('error', err);
  }

  /**
   * Handle new WebSocket client SslErrors.
   */
  function _isSslErrors (errors) {
    var err = {
      message: "sOnSslErrors: " + errors
    };
    self.emit('error', err);
  }

  this.QWebSocketServer["acceptError(QAbstractSocket::SocketError)"].connect(_isAcceptError);
  this.QWebSocketServer["newConnection()"].connect(_isNewConnection);
  this.QWebSocketServer["originAuthenticationRequired(QWebSocketCorsAuthenticator *)"].connect(_isOriginAuthenticationRequired);
  this.QWebSocketServer["peerVerifyError(QSslError)"].connect(_isPeerVerifyError);
  this.QWebSocketServer["serverError(QWebSocketProtocol::CloseCode)"].connect(_isServerError);
  this.QWebSocketServer["sslErrors(QList<QSslError>)"].connect(_isSslErrors);

  if (typeof callback === 'function') {
    this.once('listening', callback);
  }

  if (options.port && options.port > 0) {
    this.listen(options.port, options.host, callback);
  }
};

util.inherits(WebSocketServer, EventEmitter);

function isLegalPort(port) {
  return (port >= 0 && port < 65536);
}

function isPipeName(s) {
  return typeof s === 'string' && toNumber(s) === false;
}

function toNumber(x) {
  return (x = Number(x)) >= 0 ? x : false;
}

/**
 * Emulate Node.js's `ws.close([callback])` method.
 * @See: https://github.com/websockets/ws/blob/1.1.0/doc/ws.md#serverclosecallback
 *
 * @param {Function} [callback] - The callback to call when the server is closed.
 */
WebSocketServer.prototype.close = function close (callback) {
  var self = this;

  // Terminate all associated clients.
  var error = null;
  try {
    for (var i = 0, l = this.clients.length; i < l; ++i) {
      this.clients[i].terminate();
    }
  } catch (e) {
    error = e;
  }

  // Remove path descriptor, if any.
  if (this.path && this._webSocketPaths) {
    delete this._webSocketPaths[this.path];
    if (Object.keys(this._webSocketPaths).length == 0) {
      delete this._webSocketPaths;
    }
  }

  // Close the QWebSocketServer server.
  try {
    if (typeof this.QWebSocketServer !== 'undefined') {
      if (typeof this.QWebSocketServer.close === 'function') {
        this.QWebSocketServer.close();
      }

      if (typeof callback === 'function') {
        this.once('close', function() {
          callback(error);
        });
      } else if (error) {
        throw error;
      }
    }
  } finally {
    this.removeListener('listening', this._onceServerListening);
    this.removeListener('error', this._onServerError);
    this.removeListener('upgrade', this._onServerUpgrade);
    delete this.QWebSocketServer;

    process.nextTick(function () {
      self.emit('close');
    }, self);
  }

  return this;
};

/**
 * Private helper function for `server.listen()`.
 *
 * @param {Object} self - The `WebSocketServer` object.
 * @param {String} [address] - The address to listen on.
 * @param {Number} [port] - The port to listen on.
 * @param {Number} [addressType] - The IP address type, IPv4 === 4, IPv6 === 6.
 * @param {Number} [backlog] - The max pending connections to allow.
 *
 * @private
 */
function _listen(self, address, port, addressType, backlog) {
  if (backlog > 0) {
    self.QWebSocketServer.setMaxPendingConnections(backlog);
    self.maxConnections = backlog;
  }

  if (!self.QWebSocketServer.listen(QHostAddress(address), port)) {
    var message = "An unidentified error occurred when start to listen for the QWebSocketServer.";
    if (self.QWebSocketServer.error() !== QWebSocketProtocol.CloseCodeNormal) {
      var message = self.QWebSocketServer.errorString();
    }

    var err = {
      message: message + " WebSocket Server address:port: " + address + ":" + port
    };

    return self.emit('error', err);
  }

  var url = QUrl(self.QWebSocketServer.serverUrl());
  self._url = url.toString();
  self._host = url.host;

  // generate connection key, this should be unique to the connection
  self._connectionKey = addressType + ':' + address + ':' + port;

  process.nextTick(function () {
    self.emit('listening');
  }, self);
}

/**
 * Emulate Node.js's
 * `server.listen(handle[, backlog][, callback])`,
 * `server.listen(options[, callback])`,
 * `server.listen(path[, backlog][, callback])`,
 * `server.listen(port[, hostname][, backlog][, callback])` methods.
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_server_listen_handle_backlog_callback
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_server_listen_options_callback
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_server_listen_path_backlog_callback
 * @See: https://nodejs.org/dist/latest-v4.x/docs/api/net.html#net_server_listen_port_hostname_backlog_callback
 *
 * @param {Object | Number} - The config optoins | port to listen on.
 * @param {String | Function | Number} - The hostname to listen on | listen callback | max pending connections to allow.
 * @param {Function | Number} - The listen callback | max pending connections to allow.
 * @param {Function} - The listen callback.
 */
WebSocketServer.prototype.listen = function listen () {
  var self = this;

  var lastArg = arguments[arguments.length - 1];
  if (typeof lastArg === 'function') {
    self.once('listening', lastArg);
  }

  var port = toNumber(arguments[0]);

  // The third optional argument is the backlog size.
  // When the ip is omitted it can be the second argument.
  var backlog = toNumber(arguments[1]) || toNumber(arguments[2]);

  if (arguments.length === 0 || typeof arguments[0] === 'function') {
    // Bind to a random port.
    _listen(self, null, 0, null, backlog);
  } else if (arguments[0] !== null && typeof arguments[0] === 'object') {
    var h = arguments[0];
    h = h._handle || h.handle || h;

    if (h instanceof WebSocketServer || h instanceof WebSocket) {
      //self._handle = h;
      //_listen(self, null, -1, -1, backlog);
      throw new Error('WebSocketServer.listen on an existing WebSocketServer or WebSocket argument is not supported.');
    } else if (typeof h.fd === 'number' && h.fd >= 0) {
      //_listen(self, null, null, null, backlog, h.fd);
      // TODO: This could be implimented with QFileDevice.
      throw new Error('WebSocketServer.listen on an file discripter argument is not supported.');
    } else {
      // The first argument is a configuration object
      if (h.backlog)
        backlog = h.backlog;

      if (typeof h.port === 'number' || typeof h.port === 'string' ||
          (typeof h.port === 'undefined' && 'port' in h)) {
        // Undefined is interpreted as zero (random port) for consistency
        // with net.connect().
        if (typeof h.port !== 'undefined' && !isLegalPort(h.port))
          throw new RangeError('port should be >= 0 and < 65536: ' + h.port);
        if (h.host)
          listenAfterLookup(h.port | 0, h.host, backlog, h.exclusive);
        else
          _listen(self, null, h.port | 0, 4, backlog, undefined, h.exclusive);
      } else if (h.path && isPipeName(h.path)) {
        //var pipeName = self._pipeName = h.path;
        //_listen(self, pipeName, -1, -1, backlog, undefined, h.exclusive);
        // TODO: This could be implimented with QFileDevice or QLocalSocket.
        throw new Error('Local path socket server is not supported.');
      } else {
        throw new Error('Invalid listen argument: ' + h);
      }
    }
  } else if (isPipeName(arguments[0])) {
    // UNIX socket or Windows pipe.
    //var pipeName = self._pipeName = arguments[0];
    //_listen(self, pipeName, -1, -1, backlog);
    // TODO: This could be implimented with QFileDevice or QLocalSocket.
    throw new Error('Local path socket server is not supported.');
  } else if (arguments[1] === undefined ||
             typeof arguments[1] === 'function' ||
             typeof arguments[1] === 'number') {
    // The first argument is the port, no IP given.
    _listen(self, null, port, 4, backlog);

  } else {
    // The first argument is the port, the second an IP.
    listenAfterLookup(port, arguments[1], backlog);
  }

  function listenAfterLookup(port, address, backlog, exclusive) {
    if (address === 'localhost') {
      _listen(self, '127.0.0.1', port, 4, backlog, undefined, exclusive);
    } else if (address === '::1') {
      _listen(self, address, port, 6, backlog, undefined, exclusive);
    } else if (address === '127.0.0.1') {
      _listen(self, address, port, 4, backlog, undefined, exclusive);
    } else {
      require('dns').lookup(address, function(err, ip, addressType) {
        if (err) {
          self.emit('error', err);
        } else {
          addressType = ip ? addressType : 4;
          _listen(self, ip, port, addressType, backlog, undefined, exclusive);
        }
      });
    }
  }

  return self;
};

/**
 * Private helper function to handle the incomming client connections to this
 * WebSocket Server.
 *
 * @private
 */
WebSocketServer.prototype._handleConnection = function() {
  var self = this;
  var webSocket = this.QWebSocketServer.nextPendingConnection();

  // We can't call webSocket.error() because it conflicts with the error signal exposure in Qt Script.
  if (webSocket.errorString() !== 'Unknown error') { // 'Unknown error' is what is returned when there is no error.
    this.emit('error', new Error(webSocket.errorString() + ' accept'));
    return;
  }

  if (this.maxConnections && this._connections >= this.maxConnections) {
    webSocket.abort();
    return;
  }

  var socketOptions = {
    _server: this
  };
  var socket = new WebSocket([webSocket], socketOptions);
  socket.readable = socket.writable = true;

  // Handle premature socket errors.
  var errorHandler = function () {
    try {
      socket.destroy();
    } catch (e) {}
  };
  socket.on('error', errorHandler);

  this._connections++;
  socket.server = this;
  socket._server = this;

  // Check for wrong path.
  if (this.options.path) {
    var u = url.parse(socket.QWebSocket.urlrequestUrl().toString());
    if (u && u.pathname !== this.options.path) {
      this.clientOrigin = null;
      return;
    }
  }

  var req = socket.upgradeReq;

  // Optionally call external client verification handler.
  if (typeof this.options.verifyClient == 'function') {
    var info = {
      origin: this.clientOrigin,
      secure: this.options.secureMode,
      req: req
    };
    this.clientOrigin = null;

    if (this.options.verifyClient.length == 2) {
      this.options.verifyClient(info, function(result, code, name) {
        if (typeof code === 'undefined') code = 401;
        if (typeof name === 'undefined') name = http.STATUS_CODES[code];

        if (!result) {
          webSocket.close(QWebSocketProtocol.CloseCodePolicyViolated, name);
        } else {
          process.nextTick(function () {
            self.emit('connection', socket);
          }, this);
        }
      });
      return;
    } else if (!this.options.verifyClient(info)) {
      webSocket.close(QWebSocketProtocol.CloseCodePolicyViolated, 'Unauthorized');
      return;
    } else {
      process.nextTick(function () {
        self.emit('connection', socket);
      }, this);
    }
  } else {
    this.clientOrigin = null;
    process.nextTick(function () {
      self.emit('connection', socket);
    }, this);
  }

  if (this.options.clientTracking) {
    this.clients.push(socket);
    socket.on('close', function() {
      var index = self.clients.indexOf(socket);
      if (index != -1) {
        self.clients.splice(index, 1);
      }
    });
  }

  socket.removeListener('error', errorHandler);
};

module.exports = WebSocketServer;

},{"./WebSocket.qtscript":1,"dns":undefined,"events":undefined,"http":undefined,"url":undefined,"util":undefined}],3:[function(require,module,exports){
/**
 * Helper function to convert the hash's encoded data to a Qt QByteArray.
 *
 * @param {String | Buffer} data - The data to hash. If data is a Buffer then encoding is ignored.
 * @param {String} [encoding] - The encoding given can be 'utf8', 'ascii' or 'binary'.
 *   If no encoding is provided, and the input is a string, an encoding of 'binary' is enforced.
 * @return {QByteArray | Boolean} - A QByteArray of the data.
 * @private
 */
var _convertEncodingToQByteArray = function _convertEncodingToQByteArray (data, encoding) {
  var qba;
  if (Buffer.isBuffer(data)) {
    if (data.QByteArray) {
      //qba = new QByteArray(data.QByteArray);
      qba = data.QByteArray;
    } else {
      qba = new QByteArray(data.length, 0);
      var size = data.length;
      for (var i = 0; i < size; i++) {
        qba.replace(i, 1, QByteArray(1, data[i]));
      }
    }
  } else {
    switch (encoding) {
      // TODO: Do we need to do any conversion?
      case 'ascii':
      case 'binary':
      case 'utf8':
        qba = new QByteArray(data);
        break;
      default:
        if (typeof data === 'string') {
          // Node.js's default is 'binary'.
          qba = _convertEncodingToQByteArray (data, 'binary')
        } else {
          return false;
        }
    }
  }

  return qba;
};

/**
 * Helper function to convert a Qt QByteArray to the encoding format.
 *
 * @param {QByteArray} qba - The QByteArray to convert.
 * @param {String} [encoding] - The encoding can be 'hex', 'binary' or 'base64'.
 *   If no encoding is provided, then a buffer is returned.
 * @return {String | Buffer} - The encoded QByteArray data.
 * @private
 */
var _convertQByteArrayToEncoding = function _convertQByteArrayToEncoding (qba, encoding) {
  var data;
  switch (encoding) {
    case 'base64':
      data = qba.toBase64();
      break;
    case 'binary':
      data = qba.toString();
      break;
    case 'hex':
      data = qba.toHex();
      break;
    case 'utf8':
    case 'utf-8':
    default:
      // Utf8 encode the QByteArray.
      //var encodedQba = new QByteArray(qba.toString());
      var encodedQba = new QByteArray(qba.toLatin1());

      // Node.js's default is a Buffer.
      if (Buffer.fromQByteArray) {
        data = Buffer.fromQByteArray(encodedQba);
      } else {
        var buffer = new Buffer(encodedQba.size());
        var mask = (1 << 8) -1;
        // HEX conversion is slower.
        //var hex = encodedQba.toHex().toString();
        //buffer.write(hex, "hex");
        var size = encodedQba.size();
        for (var i = 0; i < size; i++) {
          buffer[i] = encodedQba.at(i) & mask;
        }
        data = buffer;
      }
  }

  return data;
};

/**
 * Helper function to get the IP protocol.
 *
 * @param {Number} [input] - The address to get the IP protocol for.
 * @return {String | Boolean} - The IP protocol or false.
 * @private
 */
var _getIpProtocol = function _getIpProtocol (input) {
  var address = new QHostAddress(input);

  if (address.isNull()) {
    return false;
  } else {
    return _mapIpProtocol(address.protocol());
  }
};

/**
 * Helper function to get the IP protocol.
 *
 * @param {Number} networkLayerProtocol - The `enum QAbstractSocket::NetworkLayerProtocol` integer.
 * @return {String} - The IP protocol.
 * @private
 */
var _mapIpProtocol = function _mapIpProtocol (networkLayerProtocol) {
  switch (networkLayerProtocol) {
    case 0:
      return 'IPv4';
    case 1:
      return 'IPv6';
    default:
      return null;
  }
};

module.exports = {
  _convertEncodingToQByteArray: _convertEncodingToQByteArray,
  _convertQByteArrayToEncoding: _convertQByteArrayToEncoding,
  _getIpProtocol: _getIpProtocol,
  _mapIpProtocol: _mapIpProtocol
};

},{}],"ws":[function(require,module,exports){
'use strict';

/*!
 * ws: a node.js websocket client
 * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>
 * MIT Licensed
 */

var WS = require('./WebSocket.qtscript');

WS.Server = require('./WebSocketServer.qtscript');

/**
 * Create a new WebSocket server.
 *
 * @param {Object} options Server options
 * @param {Function} fn Optional connection listener.
 * @returns {WS.Server}
 * @api public
 */
WS.createServer = function createServer(options, fn) {
  var server = new WS.Server(options);

  if (typeof fn === 'function') {
    server.on('connection', fn);
  }

  return server;
};

/**
 * Create a new WebSocket connection.
 *
 * @param {String} address The URL/address we need to connect to.
 * @param {Function} fn Open listener.
 * @returns {WS}
 * @api public
 */
WS.connect = WS.createConnection = function connect(address, fn) {
  var client = new WS(address);

  if (typeof fn === 'function') {
    client.on('open', fn);
  }

  return client;
};

module.exports = WS;

},{"./WebSocket.qtscript":1,"./WebSocketServer.qtscript":2}]},{},[]); 
$code_body$::text); 
